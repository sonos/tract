// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tflite {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TENSOR_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TENSOR_TYPE: i8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TENSOR_TYPE: [TensorType; 18] = [
  TensorType::FLOAT32,
  TensorType::FLOAT16,
  TensorType::INT32,
  TensorType::UINT8,
  TensorType::INT64,
  TensorType::STRING,
  TensorType::BOOL,
  TensorType::INT16,
  TensorType::COMPLEX64,
  TensorType::INT8,
  TensorType::FLOAT64,
  TensorType::COMPLEX128,
  TensorType::UINT64,
  TensorType::RESOURCE,
  TensorType::VARIANT,
  TensorType::UINT32,
  TensorType::UINT16,
  TensorType::INT4,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TensorType(pub i8);
#[allow(non_upper_case_globals)]
impl TensorType {
  pub const FLOAT32: Self = Self(0);
  pub const FLOAT16: Self = Self(1);
  pub const INT32: Self = Self(2);
  pub const UINT8: Self = Self(3);
  pub const INT64: Self = Self(4);
  pub const STRING: Self = Self(5);
  pub const BOOL: Self = Self(6);
  pub const INT16: Self = Self(7);
  pub const COMPLEX64: Self = Self(8);
  pub const INT8: Self = Self(9);
  pub const FLOAT64: Self = Self(10);
  pub const COMPLEX128: Self = Self(11);
  pub const UINT64: Self = Self(12);
  pub const RESOURCE: Self = Self(13);
  pub const VARIANT: Self = Self(14);
  pub const UINT32: Self = Self(15);
  pub const UINT16: Self = Self(16);
  pub const INT4: Self = Self(17);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FLOAT32,
    Self::FLOAT16,
    Self::INT32,
    Self::UINT8,
    Self::INT64,
    Self::STRING,
    Self::BOOL,
    Self::INT16,
    Self::COMPLEX64,
    Self::INT8,
    Self::FLOAT64,
    Self::COMPLEX128,
    Self::UINT64,
    Self::RESOURCE,
    Self::VARIANT,
    Self::UINT32,
    Self::UINT16,
    Self::INT4,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FLOAT32 => Some("FLOAT32"),
      Self::FLOAT16 => Some("FLOAT16"),
      Self::INT32 => Some("INT32"),
      Self::UINT8 => Some("UINT8"),
      Self::INT64 => Some("INT64"),
      Self::STRING => Some("STRING"),
      Self::BOOL => Some("BOOL"),
      Self::INT16 => Some("INT16"),
      Self::COMPLEX64 => Some("COMPLEX64"),
      Self::INT8 => Some("INT8"),
      Self::FLOAT64 => Some("FLOAT64"),
      Self::COMPLEX128 => Some("COMPLEX128"),
      Self::UINT64 => Some("UINT64"),
      Self::RESOURCE => Some("RESOURCE"),
      Self::VARIANT => Some("VARIANT"),
      Self::UINT32 => Some("UINT32"),
      Self::UINT16 => Some("UINT16"),
      Self::INT4 => Some("INT4"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TensorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TensorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TensorType {
    type Output = TensorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TensorType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TensorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TensorType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_QUANTIZATION_DETAILS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_QUANTIZATION_DETAILS: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_QUANTIZATION_DETAILS: [QuantizationDetails; 2] = [
  QuantizationDetails::NONE,
  QuantizationDetails::CustomQuantization,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct QuantizationDetails(pub u8);
#[allow(non_upper_case_globals)]
impl QuantizationDetails {
  pub const NONE: Self = Self(0);
  pub const CustomQuantization: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CustomQuantization,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CustomQuantization => Some("CustomQuantization"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for QuantizationDetails {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for QuantizationDetails {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for QuantizationDetails {
    type Output = QuantizationDetails;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for QuantizationDetails {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for QuantizationDetails {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for QuantizationDetails {}
pub struct QuantizationDetailsUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_TYPE: [DimensionType; 2] = [
  DimensionType::DENSE,
  DimensionType::SPARSE_CSR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DimensionType(pub i8);
#[allow(non_upper_case_globals)]
impl DimensionType {
  pub const DENSE: Self = Self(0);
  pub const SPARSE_CSR: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DENSE,
    Self::SPARSE_CSR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DENSE => Some("DENSE"),
      Self::SPARSE_CSR => Some("SPARSE_CSR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DimensionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DimensionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DimensionType {
    type Output = DimensionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DimensionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DimensionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DimensionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPARSE_INDEX_VECTOR: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPARSE_INDEX_VECTOR: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPARSE_INDEX_VECTOR: [SparseIndexVector; 4] = [
  SparseIndexVector::NONE,
  SparseIndexVector::Int32Vector,
  SparseIndexVector::Uint16Vector,
  SparseIndexVector::Uint8Vector,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SparseIndexVector(pub u8);
#[allow(non_upper_case_globals)]
impl SparseIndexVector {
  pub const NONE: Self = Self(0);
  pub const Int32Vector: Self = Self(1);
  pub const Uint16Vector: Self = Self(2);
  pub const Uint8Vector: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Int32Vector,
    Self::Uint16Vector,
    Self::Uint8Vector,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Int32Vector => Some("Int32Vector"),
      Self::Uint16Vector => Some("Uint16Vector"),
      Self::Uint8Vector => Some("Uint8Vector"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SparseIndexVector {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SparseIndexVector {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SparseIndexVector {
    type Output = SparseIndexVector;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SparseIndexVector {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SparseIndexVector {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SparseIndexVector {}
pub struct SparseIndexVectorUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUILTIN_OPERATOR: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUILTIN_OPERATOR: i32 = 161;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUILTIN_OPERATOR: [BuiltinOperator; 162] = [
  BuiltinOperator::ADD,
  BuiltinOperator::AVERAGE_POOL_2D,
  BuiltinOperator::CONCATENATION,
  BuiltinOperator::CONV_2D,
  BuiltinOperator::DEPTHWISE_CONV_2D,
  BuiltinOperator::DEPTH_TO_SPACE,
  BuiltinOperator::DEQUANTIZE,
  BuiltinOperator::EMBEDDING_LOOKUP,
  BuiltinOperator::FLOOR,
  BuiltinOperator::FULLY_CONNECTED,
  BuiltinOperator::HASHTABLE_LOOKUP,
  BuiltinOperator::L2_NORMALIZATION,
  BuiltinOperator::L2_POOL_2D,
  BuiltinOperator::LOCAL_RESPONSE_NORMALIZATION,
  BuiltinOperator::LOGISTIC,
  BuiltinOperator::LSH_PROJECTION,
  BuiltinOperator::LSTM,
  BuiltinOperator::MAX_POOL_2D,
  BuiltinOperator::MUL,
  BuiltinOperator::RELU,
  BuiltinOperator::RELU_N1_TO_1,
  BuiltinOperator::RELU6,
  BuiltinOperator::RESHAPE,
  BuiltinOperator::RESIZE_BILINEAR,
  BuiltinOperator::RNN,
  BuiltinOperator::SOFTMAX,
  BuiltinOperator::SPACE_TO_DEPTH,
  BuiltinOperator::SVDF,
  BuiltinOperator::TANH,
  BuiltinOperator::CONCAT_EMBEDDINGS,
  BuiltinOperator::SKIP_GRAM,
  BuiltinOperator::CALL,
  BuiltinOperator::CUSTOM,
  BuiltinOperator::EMBEDDING_LOOKUP_SPARSE,
  BuiltinOperator::PAD,
  BuiltinOperator::UNIDIRECTIONAL_SEQUENCE_RNN,
  BuiltinOperator::GATHER,
  BuiltinOperator::BATCH_TO_SPACE_ND,
  BuiltinOperator::SPACE_TO_BATCH_ND,
  BuiltinOperator::TRANSPOSE,
  BuiltinOperator::MEAN,
  BuiltinOperator::SUB,
  BuiltinOperator::DIV,
  BuiltinOperator::SQUEEZE,
  BuiltinOperator::UNIDIRECTIONAL_SEQUENCE_LSTM,
  BuiltinOperator::STRIDED_SLICE,
  BuiltinOperator::BIDIRECTIONAL_SEQUENCE_RNN,
  BuiltinOperator::EXP,
  BuiltinOperator::TOPK_V2,
  BuiltinOperator::SPLIT,
  BuiltinOperator::LOG_SOFTMAX,
  BuiltinOperator::DELEGATE,
  BuiltinOperator::BIDIRECTIONAL_SEQUENCE_LSTM,
  BuiltinOperator::CAST,
  BuiltinOperator::PRELU,
  BuiltinOperator::MAXIMUM,
  BuiltinOperator::ARG_MAX,
  BuiltinOperator::MINIMUM,
  BuiltinOperator::LESS,
  BuiltinOperator::NEG,
  BuiltinOperator::PADV2,
  BuiltinOperator::GREATER,
  BuiltinOperator::GREATER_EQUAL,
  BuiltinOperator::LESS_EQUAL,
  BuiltinOperator::SELECT,
  BuiltinOperator::SLICE,
  BuiltinOperator::SIN,
  BuiltinOperator::TRANSPOSE_CONV,
  BuiltinOperator::SPARSE_TO_DENSE,
  BuiltinOperator::TILE,
  BuiltinOperator::EXPAND_DIMS,
  BuiltinOperator::EQUAL,
  BuiltinOperator::NOT_EQUAL,
  BuiltinOperator::LOG,
  BuiltinOperator::SUM,
  BuiltinOperator::SQRT,
  BuiltinOperator::RSQRT,
  BuiltinOperator::SHAPE,
  BuiltinOperator::POW,
  BuiltinOperator::ARG_MIN,
  BuiltinOperator::FAKE_QUANT,
  BuiltinOperator::REDUCE_PROD,
  BuiltinOperator::REDUCE_MAX,
  BuiltinOperator::PACK,
  BuiltinOperator::LOGICAL_OR,
  BuiltinOperator::ONE_HOT,
  BuiltinOperator::LOGICAL_AND,
  BuiltinOperator::LOGICAL_NOT,
  BuiltinOperator::UNPACK,
  BuiltinOperator::REDUCE_MIN,
  BuiltinOperator::FLOOR_DIV,
  BuiltinOperator::REDUCE_ANY,
  BuiltinOperator::SQUARE,
  BuiltinOperator::ZEROS_LIKE,
  BuiltinOperator::FILL,
  BuiltinOperator::FLOOR_MOD,
  BuiltinOperator::RANGE,
  BuiltinOperator::RESIZE_NEAREST_NEIGHBOR,
  BuiltinOperator::LEAKY_RELU,
  BuiltinOperator::SQUARED_DIFFERENCE,
  BuiltinOperator::MIRROR_PAD,
  BuiltinOperator::ABS,
  BuiltinOperator::SPLIT_V,
  BuiltinOperator::UNIQUE,
  BuiltinOperator::CEIL,
  BuiltinOperator::REVERSE_V2,
  BuiltinOperator::ADD_N,
  BuiltinOperator::GATHER_ND,
  BuiltinOperator::COS,
  BuiltinOperator::WHERE,
  BuiltinOperator::RANK,
  BuiltinOperator::ELU,
  BuiltinOperator::REVERSE_SEQUENCE,
  BuiltinOperator::MATRIX_DIAG,
  BuiltinOperator::QUANTIZE,
  BuiltinOperator::MATRIX_SET_DIAG,
  BuiltinOperator::ROUND,
  BuiltinOperator::HARD_SWISH,
  BuiltinOperator::IF,
  BuiltinOperator::WHILE,
  BuiltinOperator::NON_MAX_SUPPRESSION_V4,
  BuiltinOperator::NON_MAX_SUPPRESSION_V5,
  BuiltinOperator::SCATTER_ND,
  BuiltinOperator::SELECT_V2,
  BuiltinOperator::DENSIFY,
  BuiltinOperator::SEGMENT_SUM,
  BuiltinOperator::BATCH_MATMUL,
  BuiltinOperator::PLACEHOLDER_FOR_GREATER_OP_CODES,
  BuiltinOperator::CUMSUM,
  BuiltinOperator::CALL_ONCE,
  BuiltinOperator::BROADCAST_TO,
  BuiltinOperator::RFFT2D,
  BuiltinOperator::CONV_3D,
  BuiltinOperator::IMAG,
  BuiltinOperator::REAL,
  BuiltinOperator::COMPLEX_ABS,
  BuiltinOperator::HASHTABLE,
  BuiltinOperator::HASHTABLE_FIND,
  BuiltinOperator::HASHTABLE_IMPORT,
  BuiltinOperator::HASHTABLE_SIZE,
  BuiltinOperator::REDUCE_ALL,
  BuiltinOperator::CONV_3D_TRANSPOSE,
  BuiltinOperator::VAR_HANDLE,
  BuiltinOperator::READ_VARIABLE,
  BuiltinOperator::ASSIGN_VARIABLE,
  BuiltinOperator::BROADCAST_ARGS,
  BuiltinOperator::RANDOM_STANDARD_NORMAL,
  BuiltinOperator::BUCKETIZE,
  BuiltinOperator::RANDOM_UNIFORM,
  BuiltinOperator::MULTINOMIAL,
  BuiltinOperator::GELU,
  BuiltinOperator::DYNAMIC_UPDATE_SLICE,
  BuiltinOperator::RELU_0_TO_1,
  BuiltinOperator::UNSORTED_SEGMENT_PROD,
  BuiltinOperator::UNSORTED_SEGMENT_MAX,
  BuiltinOperator::UNSORTED_SEGMENT_SUM,
  BuiltinOperator::ATAN2,
  BuiltinOperator::UNSORTED_SEGMENT_MIN,
  BuiltinOperator::SIGN,
  BuiltinOperator::BITCAST,
  BuiltinOperator::BITWISE_XOR,
  BuiltinOperator::RIGHT_SHIFT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BuiltinOperator(pub i32);
#[allow(non_upper_case_globals)]
impl BuiltinOperator {
  pub const ADD: Self = Self(0);
  pub const AVERAGE_POOL_2D: Self = Self(1);
  pub const CONCATENATION: Self = Self(2);
  pub const CONV_2D: Self = Self(3);
  pub const DEPTHWISE_CONV_2D: Self = Self(4);
  pub const DEPTH_TO_SPACE: Self = Self(5);
  pub const DEQUANTIZE: Self = Self(6);
  pub const EMBEDDING_LOOKUP: Self = Self(7);
  pub const FLOOR: Self = Self(8);
  pub const FULLY_CONNECTED: Self = Self(9);
  pub const HASHTABLE_LOOKUP: Self = Self(10);
  pub const L2_NORMALIZATION: Self = Self(11);
  pub const L2_POOL_2D: Self = Self(12);
  pub const LOCAL_RESPONSE_NORMALIZATION: Self = Self(13);
  pub const LOGISTIC: Self = Self(14);
  pub const LSH_PROJECTION: Self = Self(15);
  pub const LSTM: Self = Self(16);
  pub const MAX_POOL_2D: Self = Self(17);
  pub const MUL: Self = Self(18);
  pub const RELU: Self = Self(19);
  pub const RELU_N1_TO_1: Self = Self(20);
  pub const RELU6: Self = Self(21);
  pub const RESHAPE: Self = Self(22);
  pub const RESIZE_BILINEAR: Self = Self(23);
  pub const RNN: Self = Self(24);
  pub const SOFTMAX: Self = Self(25);
  pub const SPACE_TO_DEPTH: Self = Self(26);
  pub const SVDF: Self = Self(27);
  pub const TANH: Self = Self(28);
  pub const CONCAT_EMBEDDINGS: Self = Self(29);
  pub const SKIP_GRAM: Self = Self(30);
  pub const CALL: Self = Self(31);
  pub const CUSTOM: Self = Self(32);
  pub const EMBEDDING_LOOKUP_SPARSE: Self = Self(33);
  pub const PAD: Self = Self(34);
  pub const UNIDIRECTIONAL_SEQUENCE_RNN: Self = Self(35);
  pub const GATHER: Self = Self(36);
  pub const BATCH_TO_SPACE_ND: Self = Self(37);
  pub const SPACE_TO_BATCH_ND: Self = Self(38);
  pub const TRANSPOSE: Self = Self(39);
  pub const MEAN: Self = Self(40);
  pub const SUB: Self = Self(41);
  pub const DIV: Self = Self(42);
  pub const SQUEEZE: Self = Self(43);
  pub const UNIDIRECTIONAL_SEQUENCE_LSTM: Self = Self(44);
  pub const STRIDED_SLICE: Self = Self(45);
  pub const BIDIRECTIONAL_SEQUENCE_RNN: Self = Self(46);
  pub const EXP: Self = Self(47);
  pub const TOPK_V2: Self = Self(48);
  pub const SPLIT: Self = Self(49);
  pub const LOG_SOFTMAX: Self = Self(50);
  pub const DELEGATE: Self = Self(51);
  pub const BIDIRECTIONAL_SEQUENCE_LSTM: Self = Self(52);
  pub const CAST: Self = Self(53);
  pub const PRELU: Self = Self(54);
  pub const MAXIMUM: Self = Self(55);
  pub const ARG_MAX: Self = Self(56);
  pub const MINIMUM: Self = Self(57);
  pub const LESS: Self = Self(58);
  pub const NEG: Self = Self(59);
  pub const PADV2: Self = Self(60);
  pub const GREATER: Self = Self(61);
  pub const GREATER_EQUAL: Self = Self(62);
  pub const LESS_EQUAL: Self = Self(63);
  pub const SELECT: Self = Self(64);
  pub const SLICE: Self = Self(65);
  pub const SIN: Self = Self(66);
  pub const TRANSPOSE_CONV: Self = Self(67);
  pub const SPARSE_TO_DENSE: Self = Self(68);
  pub const TILE: Self = Self(69);
  pub const EXPAND_DIMS: Self = Self(70);
  pub const EQUAL: Self = Self(71);
  pub const NOT_EQUAL: Self = Self(72);
  pub const LOG: Self = Self(73);
  pub const SUM: Self = Self(74);
  pub const SQRT: Self = Self(75);
  pub const RSQRT: Self = Self(76);
  pub const SHAPE: Self = Self(77);
  pub const POW: Self = Self(78);
  pub const ARG_MIN: Self = Self(79);
  pub const FAKE_QUANT: Self = Self(80);
  pub const REDUCE_PROD: Self = Self(81);
  pub const REDUCE_MAX: Self = Self(82);
  pub const PACK: Self = Self(83);
  pub const LOGICAL_OR: Self = Self(84);
  pub const ONE_HOT: Self = Self(85);
  pub const LOGICAL_AND: Self = Self(86);
  pub const LOGICAL_NOT: Self = Self(87);
  pub const UNPACK: Self = Self(88);
  pub const REDUCE_MIN: Self = Self(89);
  pub const FLOOR_DIV: Self = Self(90);
  pub const REDUCE_ANY: Self = Self(91);
  pub const SQUARE: Self = Self(92);
  pub const ZEROS_LIKE: Self = Self(93);
  pub const FILL: Self = Self(94);
  pub const FLOOR_MOD: Self = Self(95);
  pub const RANGE: Self = Self(96);
  pub const RESIZE_NEAREST_NEIGHBOR: Self = Self(97);
  pub const LEAKY_RELU: Self = Self(98);
  pub const SQUARED_DIFFERENCE: Self = Self(99);
  pub const MIRROR_PAD: Self = Self(100);
  pub const ABS: Self = Self(101);
  pub const SPLIT_V: Self = Self(102);
  pub const UNIQUE: Self = Self(103);
  pub const CEIL: Self = Self(104);
  pub const REVERSE_V2: Self = Self(105);
  pub const ADD_N: Self = Self(106);
  pub const GATHER_ND: Self = Self(107);
  pub const COS: Self = Self(108);
  pub const WHERE: Self = Self(109);
  pub const RANK: Self = Self(110);
  pub const ELU: Self = Self(111);
  pub const REVERSE_SEQUENCE: Self = Self(112);
  pub const MATRIX_DIAG: Self = Self(113);
  pub const QUANTIZE: Self = Self(114);
  pub const MATRIX_SET_DIAG: Self = Self(115);
  pub const ROUND: Self = Self(116);
  pub const HARD_SWISH: Self = Self(117);
  pub const IF: Self = Self(118);
  pub const WHILE: Self = Self(119);
  pub const NON_MAX_SUPPRESSION_V4: Self = Self(120);
  pub const NON_MAX_SUPPRESSION_V5: Self = Self(121);
  pub const SCATTER_ND: Self = Self(122);
  pub const SELECT_V2: Self = Self(123);
  pub const DENSIFY: Self = Self(124);
  pub const SEGMENT_SUM: Self = Self(125);
  pub const BATCH_MATMUL: Self = Self(126);
  pub const PLACEHOLDER_FOR_GREATER_OP_CODES: Self = Self(127);
  pub const CUMSUM: Self = Self(128);
  pub const CALL_ONCE: Self = Self(129);
  pub const BROADCAST_TO: Self = Self(130);
  pub const RFFT2D: Self = Self(131);
  pub const CONV_3D: Self = Self(132);
  pub const IMAG: Self = Self(133);
  pub const REAL: Self = Self(134);
  pub const COMPLEX_ABS: Self = Self(135);
  pub const HASHTABLE: Self = Self(136);
  pub const HASHTABLE_FIND: Self = Self(137);
  pub const HASHTABLE_IMPORT: Self = Self(138);
  pub const HASHTABLE_SIZE: Self = Self(139);
  pub const REDUCE_ALL: Self = Self(140);
  pub const CONV_3D_TRANSPOSE: Self = Self(141);
  pub const VAR_HANDLE: Self = Self(142);
  pub const READ_VARIABLE: Self = Self(143);
  pub const ASSIGN_VARIABLE: Self = Self(144);
  pub const BROADCAST_ARGS: Self = Self(145);
  pub const RANDOM_STANDARD_NORMAL: Self = Self(146);
  pub const BUCKETIZE: Self = Self(147);
  pub const RANDOM_UNIFORM: Self = Self(148);
  pub const MULTINOMIAL: Self = Self(149);
  pub const GELU: Self = Self(150);
  pub const DYNAMIC_UPDATE_SLICE: Self = Self(151);
  pub const RELU_0_TO_1: Self = Self(152);
  pub const UNSORTED_SEGMENT_PROD: Self = Self(153);
  pub const UNSORTED_SEGMENT_MAX: Self = Self(154);
  pub const UNSORTED_SEGMENT_SUM: Self = Self(155);
  pub const ATAN2: Self = Self(156);
  pub const UNSORTED_SEGMENT_MIN: Self = Self(157);
  pub const SIGN: Self = Self(158);
  pub const BITCAST: Self = Self(159);
  pub const BITWISE_XOR: Self = Self(160);
  pub const RIGHT_SHIFT: Self = Self(161);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 161;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ADD,
    Self::AVERAGE_POOL_2D,
    Self::CONCATENATION,
    Self::CONV_2D,
    Self::DEPTHWISE_CONV_2D,
    Self::DEPTH_TO_SPACE,
    Self::DEQUANTIZE,
    Self::EMBEDDING_LOOKUP,
    Self::FLOOR,
    Self::FULLY_CONNECTED,
    Self::HASHTABLE_LOOKUP,
    Self::L2_NORMALIZATION,
    Self::L2_POOL_2D,
    Self::LOCAL_RESPONSE_NORMALIZATION,
    Self::LOGISTIC,
    Self::LSH_PROJECTION,
    Self::LSTM,
    Self::MAX_POOL_2D,
    Self::MUL,
    Self::RELU,
    Self::RELU_N1_TO_1,
    Self::RELU6,
    Self::RESHAPE,
    Self::RESIZE_BILINEAR,
    Self::RNN,
    Self::SOFTMAX,
    Self::SPACE_TO_DEPTH,
    Self::SVDF,
    Self::TANH,
    Self::CONCAT_EMBEDDINGS,
    Self::SKIP_GRAM,
    Self::CALL,
    Self::CUSTOM,
    Self::EMBEDDING_LOOKUP_SPARSE,
    Self::PAD,
    Self::UNIDIRECTIONAL_SEQUENCE_RNN,
    Self::GATHER,
    Self::BATCH_TO_SPACE_ND,
    Self::SPACE_TO_BATCH_ND,
    Self::TRANSPOSE,
    Self::MEAN,
    Self::SUB,
    Self::DIV,
    Self::SQUEEZE,
    Self::UNIDIRECTIONAL_SEQUENCE_LSTM,
    Self::STRIDED_SLICE,
    Self::BIDIRECTIONAL_SEQUENCE_RNN,
    Self::EXP,
    Self::TOPK_V2,
    Self::SPLIT,
    Self::LOG_SOFTMAX,
    Self::DELEGATE,
    Self::BIDIRECTIONAL_SEQUENCE_LSTM,
    Self::CAST,
    Self::PRELU,
    Self::MAXIMUM,
    Self::ARG_MAX,
    Self::MINIMUM,
    Self::LESS,
    Self::NEG,
    Self::PADV2,
    Self::GREATER,
    Self::GREATER_EQUAL,
    Self::LESS_EQUAL,
    Self::SELECT,
    Self::SLICE,
    Self::SIN,
    Self::TRANSPOSE_CONV,
    Self::SPARSE_TO_DENSE,
    Self::TILE,
    Self::EXPAND_DIMS,
    Self::EQUAL,
    Self::NOT_EQUAL,
    Self::LOG,
    Self::SUM,
    Self::SQRT,
    Self::RSQRT,
    Self::SHAPE,
    Self::POW,
    Self::ARG_MIN,
    Self::FAKE_QUANT,
    Self::REDUCE_PROD,
    Self::REDUCE_MAX,
    Self::PACK,
    Self::LOGICAL_OR,
    Self::ONE_HOT,
    Self::LOGICAL_AND,
    Self::LOGICAL_NOT,
    Self::UNPACK,
    Self::REDUCE_MIN,
    Self::FLOOR_DIV,
    Self::REDUCE_ANY,
    Self::SQUARE,
    Self::ZEROS_LIKE,
    Self::FILL,
    Self::FLOOR_MOD,
    Self::RANGE,
    Self::RESIZE_NEAREST_NEIGHBOR,
    Self::LEAKY_RELU,
    Self::SQUARED_DIFFERENCE,
    Self::MIRROR_PAD,
    Self::ABS,
    Self::SPLIT_V,
    Self::UNIQUE,
    Self::CEIL,
    Self::REVERSE_V2,
    Self::ADD_N,
    Self::GATHER_ND,
    Self::COS,
    Self::WHERE,
    Self::RANK,
    Self::ELU,
    Self::REVERSE_SEQUENCE,
    Self::MATRIX_DIAG,
    Self::QUANTIZE,
    Self::MATRIX_SET_DIAG,
    Self::ROUND,
    Self::HARD_SWISH,
    Self::IF,
    Self::WHILE,
    Self::NON_MAX_SUPPRESSION_V4,
    Self::NON_MAX_SUPPRESSION_V5,
    Self::SCATTER_ND,
    Self::SELECT_V2,
    Self::DENSIFY,
    Self::SEGMENT_SUM,
    Self::BATCH_MATMUL,
    Self::PLACEHOLDER_FOR_GREATER_OP_CODES,
    Self::CUMSUM,
    Self::CALL_ONCE,
    Self::BROADCAST_TO,
    Self::RFFT2D,
    Self::CONV_3D,
    Self::IMAG,
    Self::REAL,
    Self::COMPLEX_ABS,
    Self::HASHTABLE,
    Self::HASHTABLE_FIND,
    Self::HASHTABLE_IMPORT,
    Self::HASHTABLE_SIZE,
    Self::REDUCE_ALL,
    Self::CONV_3D_TRANSPOSE,
    Self::VAR_HANDLE,
    Self::READ_VARIABLE,
    Self::ASSIGN_VARIABLE,
    Self::BROADCAST_ARGS,
    Self::RANDOM_STANDARD_NORMAL,
    Self::BUCKETIZE,
    Self::RANDOM_UNIFORM,
    Self::MULTINOMIAL,
    Self::GELU,
    Self::DYNAMIC_UPDATE_SLICE,
    Self::RELU_0_TO_1,
    Self::UNSORTED_SEGMENT_PROD,
    Self::UNSORTED_SEGMENT_MAX,
    Self::UNSORTED_SEGMENT_SUM,
    Self::ATAN2,
    Self::UNSORTED_SEGMENT_MIN,
    Self::SIGN,
    Self::BITCAST,
    Self::BITWISE_XOR,
    Self::RIGHT_SHIFT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ADD => Some("ADD"),
      Self::AVERAGE_POOL_2D => Some("AVERAGE_POOL_2D"),
      Self::CONCATENATION => Some("CONCATENATION"),
      Self::CONV_2D => Some("CONV_2D"),
      Self::DEPTHWISE_CONV_2D => Some("DEPTHWISE_CONV_2D"),
      Self::DEPTH_TO_SPACE => Some("DEPTH_TO_SPACE"),
      Self::DEQUANTIZE => Some("DEQUANTIZE"),
      Self::EMBEDDING_LOOKUP => Some("EMBEDDING_LOOKUP"),
      Self::FLOOR => Some("FLOOR"),
      Self::FULLY_CONNECTED => Some("FULLY_CONNECTED"),
      Self::HASHTABLE_LOOKUP => Some("HASHTABLE_LOOKUP"),
      Self::L2_NORMALIZATION => Some("L2_NORMALIZATION"),
      Self::L2_POOL_2D => Some("L2_POOL_2D"),
      Self::LOCAL_RESPONSE_NORMALIZATION => Some("LOCAL_RESPONSE_NORMALIZATION"),
      Self::LOGISTIC => Some("LOGISTIC"),
      Self::LSH_PROJECTION => Some("LSH_PROJECTION"),
      Self::LSTM => Some("LSTM"),
      Self::MAX_POOL_2D => Some("MAX_POOL_2D"),
      Self::MUL => Some("MUL"),
      Self::RELU => Some("RELU"),
      Self::RELU_N1_TO_1 => Some("RELU_N1_TO_1"),
      Self::RELU6 => Some("RELU6"),
      Self::RESHAPE => Some("RESHAPE"),
      Self::RESIZE_BILINEAR => Some("RESIZE_BILINEAR"),
      Self::RNN => Some("RNN"),
      Self::SOFTMAX => Some("SOFTMAX"),
      Self::SPACE_TO_DEPTH => Some("SPACE_TO_DEPTH"),
      Self::SVDF => Some("SVDF"),
      Self::TANH => Some("TANH"),
      Self::CONCAT_EMBEDDINGS => Some("CONCAT_EMBEDDINGS"),
      Self::SKIP_GRAM => Some("SKIP_GRAM"),
      Self::CALL => Some("CALL"),
      Self::CUSTOM => Some("CUSTOM"),
      Self::EMBEDDING_LOOKUP_SPARSE => Some("EMBEDDING_LOOKUP_SPARSE"),
      Self::PAD => Some("PAD"),
      Self::UNIDIRECTIONAL_SEQUENCE_RNN => Some("UNIDIRECTIONAL_SEQUENCE_RNN"),
      Self::GATHER => Some("GATHER"),
      Self::BATCH_TO_SPACE_ND => Some("BATCH_TO_SPACE_ND"),
      Self::SPACE_TO_BATCH_ND => Some("SPACE_TO_BATCH_ND"),
      Self::TRANSPOSE => Some("TRANSPOSE"),
      Self::MEAN => Some("MEAN"),
      Self::SUB => Some("SUB"),
      Self::DIV => Some("DIV"),
      Self::SQUEEZE => Some("SQUEEZE"),
      Self::UNIDIRECTIONAL_SEQUENCE_LSTM => Some("UNIDIRECTIONAL_SEQUENCE_LSTM"),
      Self::STRIDED_SLICE => Some("STRIDED_SLICE"),
      Self::BIDIRECTIONAL_SEQUENCE_RNN => Some("BIDIRECTIONAL_SEQUENCE_RNN"),
      Self::EXP => Some("EXP"),
      Self::TOPK_V2 => Some("TOPK_V2"),
      Self::SPLIT => Some("SPLIT"),
      Self::LOG_SOFTMAX => Some("LOG_SOFTMAX"),
      Self::DELEGATE => Some("DELEGATE"),
      Self::BIDIRECTIONAL_SEQUENCE_LSTM => Some("BIDIRECTIONAL_SEQUENCE_LSTM"),
      Self::CAST => Some("CAST"),
      Self::PRELU => Some("PRELU"),
      Self::MAXIMUM => Some("MAXIMUM"),
      Self::ARG_MAX => Some("ARG_MAX"),
      Self::MINIMUM => Some("MINIMUM"),
      Self::LESS => Some("LESS"),
      Self::NEG => Some("NEG"),
      Self::PADV2 => Some("PADV2"),
      Self::GREATER => Some("GREATER"),
      Self::GREATER_EQUAL => Some("GREATER_EQUAL"),
      Self::LESS_EQUAL => Some("LESS_EQUAL"),
      Self::SELECT => Some("SELECT"),
      Self::SLICE => Some("SLICE"),
      Self::SIN => Some("SIN"),
      Self::TRANSPOSE_CONV => Some("TRANSPOSE_CONV"),
      Self::SPARSE_TO_DENSE => Some("SPARSE_TO_DENSE"),
      Self::TILE => Some("TILE"),
      Self::EXPAND_DIMS => Some("EXPAND_DIMS"),
      Self::EQUAL => Some("EQUAL"),
      Self::NOT_EQUAL => Some("NOT_EQUAL"),
      Self::LOG => Some("LOG"),
      Self::SUM => Some("SUM"),
      Self::SQRT => Some("SQRT"),
      Self::RSQRT => Some("RSQRT"),
      Self::SHAPE => Some("SHAPE"),
      Self::POW => Some("POW"),
      Self::ARG_MIN => Some("ARG_MIN"),
      Self::FAKE_QUANT => Some("FAKE_QUANT"),
      Self::REDUCE_PROD => Some("REDUCE_PROD"),
      Self::REDUCE_MAX => Some("REDUCE_MAX"),
      Self::PACK => Some("PACK"),
      Self::LOGICAL_OR => Some("LOGICAL_OR"),
      Self::ONE_HOT => Some("ONE_HOT"),
      Self::LOGICAL_AND => Some("LOGICAL_AND"),
      Self::LOGICAL_NOT => Some("LOGICAL_NOT"),
      Self::UNPACK => Some("UNPACK"),
      Self::REDUCE_MIN => Some("REDUCE_MIN"),
      Self::FLOOR_DIV => Some("FLOOR_DIV"),
      Self::REDUCE_ANY => Some("REDUCE_ANY"),
      Self::SQUARE => Some("SQUARE"),
      Self::ZEROS_LIKE => Some("ZEROS_LIKE"),
      Self::FILL => Some("FILL"),
      Self::FLOOR_MOD => Some("FLOOR_MOD"),
      Self::RANGE => Some("RANGE"),
      Self::RESIZE_NEAREST_NEIGHBOR => Some("RESIZE_NEAREST_NEIGHBOR"),
      Self::LEAKY_RELU => Some("LEAKY_RELU"),
      Self::SQUARED_DIFFERENCE => Some("SQUARED_DIFFERENCE"),
      Self::MIRROR_PAD => Some("MIRROR_PAD"),
      Self::ABS => Some("ABS"),
      Self::SPLIT_V => Some("SPLIT_V"),
      Self::UNIQUE => Some("UNIQUE"),
      Self::CEIL => Some("CEIL"),
      Self::REVERSE_V2 => Some("REVERSE_V2"),
      Self::ADD_N => Some("ADD_N"),
      Self::GATHER_ND => Some("GATHER_ND"),
      Self::COS => Some("COS"),
      Self::WHERE => Some("WHERE"),
      Self::RANK => Some("RANK"),
      Self::ELU => Some("ELU"),
      Self::REVERSE_SEQUENCE => Some("REVERSE_SEQUENCE"),
      Self::MATRIX_DIAG => Some("MATRIX_DIAG"),
      Self::QUANTIZE => Some("QUANTIZE"),
      Self::MATRIX_SET_DIAG => Some("MATRIX_SET_DIAG"),
      Self::ROUND => Some("ROUND"),
      Self::HARD_SWISH => Some("HARD_SWISH"),
      Self::IF => Some("IF"),
      Self::WHILE => Some("WHILE"),
      Self::NON_MAX_SUPPRESSION_V4 => Some("NON_MAX_SUPPRESSION_V4"),
      Self::NON_MAX_SUPPRESSION_V5 => Some("NON_MAX_SUPPRESSION_V5"),
      Self::SCATTER_ND => Some("SCATTER_ND"),
      Self::SELECT_V2 => Some("SELECT_V2"),
      Self::DENSIFY => Some("DENSIFY"),
      Self::SEGMENT_SUM => Some("SEGMENT_SUM"),
      Self::BATCH_MATMUL => Some("BATCH_MATMUL"),
      Self::PLACEHOLDER_FOR_GREATER_OP_CODES => Some("PLACEHOLDER_FOR_GREATER_OP_CODES"),
      Self::CUMSUM => Some("CUMSUM"),
      Self::CALL_ONCE => Some("CALL_ONCE"),
      Self::BROADCAST_TO => Some("BROADCAST_TO"),
      Self::RFFT2D => Some("RFFT2D"),
      Self::CONV_3D => Some("CONV_3D"),
      Self::IMAG => Some("IMAG"),
      Self::REAL => Some("REAL"),
      Self::COMPLEX_ABS => Some("COMPLEX_ABS"),
      Self::HASHTABLE => Some("HASHTABLE"),
      Self::HASHTABLE_FIND => Some("HASHTABLE_FIND"),
      Self::HASHTABLE_IMPORT => Some("HASHTABLE_IMPORT"),
      Self::HASHTABLE_SIZE => Some("HASHTABLE_SIZE"),
      Self::REDUCE_ALL => Some("REDUCE_ALL"),
      Self::CONV_3D_TRANSPOSE => Some("CONV_3D_TRANSPOSE"),
      Self::VAR_HANDLE => Some("VAR_HANDLE"),
      Self::READ_VARIABLE => Some("READ_VARIABLE"),
      Self::ASSIGN_VARIABLE => Some("ASSIGN_VARIABLE"),
      Self::BROADCAST_ARGS => Some("BROADCAST_ARGS"),
      Self::RANDOM_STANDARD_NORMAL => Some("RANDOM_STANDARD_NORMAL"),
      Self::BUCKETIZE => Some("BUCKETIZE"),
      Self::RANDOM_UNIFORM => Some("RANDOM_UNIFORM"),
      Self::MULTINOMIAL => Some("MULTINOMIAL"),
      Self::GELU => Some("GELU"),
      Self::DYNAMIC_UPDATE_SLICE => Some("DYNAMIC_UPDATE_SLICE"),
      Self::RELU_0_TO_1 => Some("RELU_0_TO_1"),
      Self::UNSORTED_SEGMENT_PROD => Some("UNSORTED_SEGMENT_PROD"),
      Self::UNSORTED_SEGMENT_MAX => Some("UNSORTED_SEGMENT_MAX"),
      Self::UNSORTED_SEGMENT_SUM => Some("UNSORTED_SEGMENT_SUM"),
      Self::ATAN2 => Some("ATAN2"),
      Self::UNSORTED_SEGMENT_MIN => Some("UNSORTED_SEGMENT_MIN"),
      Self::SIGN => Some("SIGN"),
      Self::BITCAST => Some("BITCAST"),
      Self::BITWISE_XOR => Some("BITWISE_XOR"),
      Self::RIGHT_SHIFT => Some("RIGHT_SHIFT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BuiltinOperator {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BuiltinOperator {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BuiltinOperator {
    type Output = BuiltinOperator;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BuiltinOperator {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BuiltinOperator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BuiltinOperator {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUILTIN_OPTIONS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUILTIN_OPTIONS: u8 = 126;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUILTIN_OPTIONS: [BuiltinOptions; 127] = [
  BuiltinOptions::NONE,
  BuiltinOptions::Conv2DOptions,
  BuiltinOptions::DepthwiseConv2DOptions,
  BuiltinOptions::ConcatEmbeddingsOptions,
  BuiltinOptions::LSHProjectionOptions,
  BuiltinOptions::Pool2DOptions,
  BuiltinOptions::SVDFOptions,
  BuiltinOptions::RNNOptions,
  BuiltinOptions::FullyConnectedOptions,
  BuiltinOptions::SoftmaxOptions,
  BuiltinOptions::ConcatenationOptions,
  BuiltinOptions::AddOptions,
  BuiltinOptions::L2NormOptions,
  BuiltinOptions::LocalResponseNormalizationOptions,
  BuiltinOptions::LSTMOptions,
  BuiltinOptions::ResizeBilinearOptions,
  BuiltinOptions::CallOptions,
  BuiltinOptions::ReshapeOptions,
  BuiltinOptions::SkipGramOptions,
  BuiltinOptions::SpaceToDepthOptions,
  BuiltinOptions::EmbeddingLookupSparseOptions,
  BuiltinOptions::MulOptions,
  BuiltinOptions::PadOptions,
  BuiltinOptions::GatherOptions,
  BuiltinOptions::BatchToSpaceNDOptions,
  BuiltinOptions::SpaceToBatchNDOptions,
  BuiltinOptions::TransposeOptions,
  BuiltinOptions::ReducerOptions,
  BuiltinOptions::SubOptions,
  BuiltinOptions::DivOptions,
  BuiltinOptions::SqueezeOptions,
  BuiltinOptions::SequenceRNNOptions,
  BuiltinOptions::StridedSliceOptions,
  BuiltinOptions::ExpOptions,
  BuiltinOptions::TopKV2Options,
  BuiltinOptions::SplitOptions,
  BuiltinOptions::LogSoftmaxOptions,
  BuiltinOptions::CastOptions,
  BuiltinOptions::DequantizeOptions,
  BuiltinOptions::MaximumMinimumOptions,
  BuiltinOptions::ArgMaxOptions,
  BuiltinOptions::LessOptions,
  BuiltinOptions::NegOptions,
  BuiltinOptions::PadV2Options,
  BuiltinOptions::GreaterOptions,
  BuiltinOptions::GreaterEqualOptions,
  BuiltinOptions::LessEqualOptions,
  BuiltinOptions::SelectOptions,
  BuiltinOptions::SliceOptions,
  BuiltinOptions::TransposeConvOptions,
  BuiltinOptions::SparseToDenseOptions,
  BuiltinOptions::TileOptions,
  BuiltinOptions::ExpandDimsOptions,
  BuiltinOptions::EqualOptions,
  BuiltinOptions::NotEqualOptions,
  BuiltinOptions::ShapeOptions,
  BuiltinOptions::PowOptions,
  BuiltinOptions::ArgMinOptions,
  BuiltinOptions::FakeQuantOptions,
  BuiltinOptions::PackOptions,
  BuiltinOptions::LogicalOrOptions,
  BuiltinOptions::OneHotOptions,
  BuiltinOptions::LogicalAndOptions,
  BuiltinOptions::LogicalNotOptions,
  BuiltinOptions::UnpackOptions,
  BuiltinOptions::FloorDivOptions,
  BuiltinOptions::SquareOptions,
  BuiltinOptions::ZerosLikeOptions,
  BuiltinOptions::FillOptions,
  BuiltinOptions::BidirectionalSequenceLSTMOptions,
  BuiltinOptions::BidirectionalSequenceRNNOptions,
  BuiltinOptions::UnidirectionalSequenceLSTMOptions,
  BuiltinOptions::FloorModOptions,
  BuiltinOptions::RangeOptions,
  BuiltinOptions::ResizeNearestNeighborOptions,
  BuiltinOptions::LeakyReluOptions,
  BuiltinOptions::SquaredDifferenceOptions,
  BuiltinOptions::MirrorPadOptions,
  BuiltinOptions::AbsOptions,
  BuiltinOptions::SplitVOptions,
  BuiltinOptions::UniqueOptions,
  BuiltinOptions::ReverseV2Options,
  BuiltinOptions::AddNOptions,
  BuiltinOptions::GatherNdOptions,
  BuiltinOptions::CosOptions,
  BuiltinOptions::WhereOptions,
  BuiltinOptions::RankOptions,
  BuiltinOptions::ReverseSequenceOptions,
  BuiltinOptions::MatrixDiagOptions,
  BuiltinOptions::QuantizeOptions,
  BuiltinOptions::MatrixSetDiagOptions,
  BuiltinOptions::HardSwishOptions,
  BuiltinOptions::IfOptions,
  BuiltinOptions::WhileOptions,
  BuiltinOptions::DepthToSpaceOptions,
  BuiltinOptions::NonMaxSuppressionV4Options,
  BuiltinOptions::NonMaxSuppressionV5Options,
  BuiltinOptions::ScatterNdOptions,
  BuiltinOptions::SelectV2Options,
  BuiltinOptions::DensifyOptions,
  BuiltinOptions::SegmentSumOptions,
  BuiltinOptions::BatchMatMulOptions,
  BuiltinOptions::CumsumOptions,
  BuiltinOptions::CallOnceOptions,
  BuiltinOptions::BroadcastToOptions,
  BuiltinOptions::Rfft2dOptions,
  BuiltinOptions::Conv3DOptions,
  BuiltinOptions::HashtableOptions,
  BuiltinOptions::HashtableFindOptions,
  BuiltinOptions::HashtableImportOptions,
  BuiltinOptions::HashtableSizeOptions,
  BuiltinOptions::VarHandleOptions,
  BuiltinOptions::ReadVariableOptions,
  BuiltinOptions::AssignVariableOptions,
  BuiltinOptions::RandomOptions,
  BuiltinOptions::BucketizeOptions,
  BuiltinOptions::GeluOptions,
  BuiltinOptions::DynamicUpdateSliceOptions,
  BuiltinOptions::UnsortedSegmentProdOptions,
  BuiltinOptions::UnsortedSegmentMaxOptions,
  BuiltinOptions::UnsortedSegmentMinOptions,
  BuiltinOptions::UnsortedSegmentSumOptions,
  BuiltinOptions::ATan2Options,
  BuiltinOptions::SignOptions,
  BuiltinOptions::BitcastOptions,
  BuiltinOptions::BitwiseXorOptions,
  BuiltinOptions::RightShiftOptions,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BuiltinOptions(pub u8);
#[allow(non_upper_case_globals)]
impl BuiltinOptions {
  pub const NONE: Self = Self(0);
  pub const Conv2DOptions: Self = Self(1);
  pub const DepthwiseConv2DOptions: Self = Self(2);
  pub const ConcatEmbeddingsOptions: Self = Self(3);
  pub const LSHProjectionOptions: Self = Self(4);
  pub const Pool2DOptions: Self = Self(5);
  pub const SVDFOptions: Self = Self(6);
  pub const RNNOptions: Self = Self(7);
  pub const FullyConnectedOptions: Self = Self(8);
  pub const SoftmaxOptions: Self = Self(9);
  pub const ConcatenationOptions: Self = Self(10);
  pub const AddOptions: Self = Self(11);
  pub const L2NormOptions: Self = Self(12);
  pub const LocalResponseNormalizationOptions: Self = Self(13);
  pub const LSTMOptions: Self = Self(14);
  pub const ResizeBilinearOptions: Self = Self(15);
  pub const CallOptions: Self = Self(16);
  pub const ReshapeOptions: Self = Self(17);
  pub const SkipGramOptions: Self = Self(18);
  pub const SpaceToDepthOptions: Self = Self(19);
  pub const EmbeddingLookupSparseOptions: Self = Self(20);
  pub const MulOptions: Self = Self(21);
  pub const PadOptions: Self = Self(22);
  pub const GatherOptions: Self = Self(23);
  pub const BatchToSpaceNDOptions: Self = Self(24);
  pub const SpaceToBatchNDOptions: Self = Self(25);
  pub const TransposeOptions: Self = Self(26);
  pub const ReducerOptions: Self = Self(27);
  pub const SubOptions: Self = Self(28);
  pub const DivOptions: Self = Self(29);
  pub const SqueezeOptions: Self = Self(30);
  pub const SequenceRNNOptions: Self = Self(31);
  pub const StridedSliceOptions: Self = Self(32);
  pub const ExpOptions: Self = Self(33);
  pub const TopKV2Options: Self = Self(34);
  pub const SplitOptions: Self = Self(35);
  pub const LogSoftmaxOptions: Self = Self(36);
  pub const CastOptions: Self = Self(37);
  pub const DequantizeOptions: Self = Self(38);
  pub const MaximumMinimumOptions: Self = Self(39);
  pub const ArgMaxOptions: Self = Self(40);
  pub const LessOptions: Self = Self(41);
  pub const NegOptions: Self = Self(42);
  pub const PadV2Options: Self = Self(43);
  pub const GreaterOptions: Self = Self(44);
  pub const GreaterEqualOptions: Self = Self(45);
  pub const LessEqualOptions: Self = Self(46);
  pub const SelectOptions: Self = Self(47);
  pub const SliceOptions: Self = Self(48);
  pub const TransposeConvOptions: Self = Self(49);
  pub const SparseToDenseOptions: Self = Self(50);
  pub const TileOptions: Self = Self(51);
  pub const ExpandDimsOptions: Self = Self(52);
  pub const EqualOptions: Self = Self(53);
  pub const NotEqualOptions: Self = Self(54);
  pub const ShapeOptions: Self = Self(55);
  pub const PowOptions: Self = Self(56);
  pub const ArgMinOptions: Self = Self(57);
  pub const FakeQuantOptions: Self = Self(58);
  pub const PackOptions: Self = Self(59);
  pub const LogicalOrOptions: Self = Self(60);
  pub const OneHotOptions: Self = Self(61);
  pub const LogicalAndOptions: Self = Self(62);
  pub const LogicalNotOptions: Self = Self(63);
  pub const UnpackOptions: Self = Self(64);
  pub const FloorDivOptions: Self = Self(65);
  pub const SquareOptions: Self = Self(66);
  pub const ZerosLikeOptions: Self = Self(67);
  pub const FillOptions: Self = Self(68);
  pub const BidirectionalSequenceLSTMOptions: Self = Self(69);
  pub const BidirectionalSequenceRNNOptions: Self = Self(70);
  pub const UnidirectionalSequenceLSTMOptions: Self = Self(71);
  pub const FloorModOptions: Self = Self(72);
  pub const RangeOptions: Self = Self(73);
  pub const ResizeNearestNeighborOptions: Self = Self(74);
  pub const LeakyReluOptions: Self = Self(75);
  pub const SquaredDifferenceOptions: Self = Self(76);
  pub const MirrorPadOptions: Self = Self(77);
  pub const AbsOptions: Self = Self(78);
  pub const SplitVOptions: Self = Self(79);
  pub const UniqueOptions: Self = Self(80);
  pub const ReverseV2Options: Self = Self(81);
  pub const AddNOptions: Self = Self(82);
  pub const GatherNdOptions: Self = Self(83);
  pub const CosOptions: Self = Self(84);
  pub const WhereOptions: Self = Self(85);
  pub const RankOptions: Self = Self(86);
  pub const ReverseSequenceOptions: Self = Self(87);
  pub const MatrixDiagOptions: Self = Self(88);
  pub const QuantizeOptions: Self = Self(89);
  pub const MatrixSetDiagOptions: Self = Self(90);
  pub const HardSwishOptions: Self = Self(91);
  pub const IfOptions: Self = Self(92);
  pub const WhileOptions: Self = Self(93);
  pub const DepthToSpaceOptions: Self = Self(94);
  pub const NonMaxSuppressionV4Options: Self = Self(95);
  pub const NonMaxSuppressionV5Options: Self = Self(96);
  pub const ScatterNdOptions: Self = Self(97);
  pub const SelectV2Options: Self = Self(98);
  pub const DensifyOptions: Self = Self(99);
  pub const SegmentSumOptions: Self = Self(100);
  pub const BatchMatMulOptions: Self = Self(101);
  pub const CumsumOptions: Self = Self(102);
  pub const CallOnceOptions: Self = Self(103);
  pub const BroadcastToOptions: Self = Self(104);
  pub const Rfft2dOptions: Self = Self(105);
  pub const Conv3DOptions: Self = Self(106);
  pub const HashtableOptions: Self = Self(107);
  pub const HashtableFindOptions: Self = Self(108);
  pub const HashtableImportOptions: Self = Self(109);
  pub const HashtableSizeOptions: Self = Self(110);
  pub const VarHandleOptions: Self = Self(111);
  pub const ReadVariableOptions: Self = Self(112);
  pub const AssignVariableOptions: Self = Self(113);
  pub const RandomOptions: Self = Self(114);
  pub const BucketizeOptions: Self = Self(115);
  pub const GeluOptions: Self = Self(116);
  pub const DynamicUpdateSliceOptions: Self = Self(117);
  pub const UnsortedSegmentProdOptions: Self = Self(118);
  pub const UnsortedSegmentMaxOptions: Self = Self(119);
  pub const UnsortedSegmentMinOptions: Self = Self(120);
  pub const UnsortedSegmentSumOptions: Self = Self(121);
  pub const ATan2Options: Self = Self(122);
  pub const SignOptions: Self = Self(123);
  pub const BitcastOptions: Self = Self(124);
  pub const BitwiseXorOptions: Self = Self(125);
  pub const RightShiftOptions: Self = Self(126);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 126;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Conv2DOptions,
    Self::DepthwiseConv2DOptions,
    Self::ConcatEmbeddingsOptions,
    Self::LSHProjectionOptions,
    Self::Pool2DOptions,
    Self::SVDFOptions,
    Self::RNNOptions,
    Self::FullyConnectedOptions,
    Self::SoftmaxOptions,
    Self::ConcatenationOptions,
    Self::AddOptions,
    Self::L2NormOptions,
    Self::LocalResponseNormalizationOptions,
    Self::LSTMOptions,
    Self::ResizeBilinearOptions,
    Self::CallOptions,
    Self::ReshapeOptions,
    Self::SkipGramOptions,
    Self::SpaceToDepthOptions,
    Self::EmbeddingLookupSparseOptions,
    Self::MulOptions,
    Self::PadOptions,
    Self::GatherOptions,
    Self::BatchToSpaceNDOptions,
    Self::SpaceToBatchNDOptions,
    Self::TransposeOptions,
    Self::ReducerOptions,
    Self::SubOptions,
    Self::DivOptions,
    Self::SqueezeOptions,
    Self::SequenceRNNOptions,
    Self::StridedSliceOptions,
    Self::ExpOptions,
    Self::TopKV2Options,
    Self::SplitOptions,
    Self::LogSoftmaxOptions,
    Self::CastOptions,
    Self::DequantizeOptions,
    Self::MaximumMinimumOptions,
    Self::ArgMaxOptions,
    Self::LessOptions,
    Self::NegOptions,
    Self::PadV2Options,
    Self::GreaterOptions,
    Self::GreaterEqualOptions,
    Self::LessEqualOptions,
    Self::SelectOptions,
    Self::SliceOptions,
    Self::TransposeConvOptions,
    Self::SparseToDenseOptions,
    Self::TileOptions,
    Self::ExpandDimsOptions,
    Self::EqualOptions,
    Self::NotEqualOptions,
    Self::ShapeOptions,
    Self::PowOptions,
    Self::ArgMinOptions,
    Self::FakeQuantOptions,
    Self::PackOptions,
    Self::LogicalOrOptions,
    Self::OneHotOptions,
    Self::LogicalAndOptions,
    Self::LogicalNotOptions,
    Self::UnpackOptions,
    Self::FloorDivOptions,
    Self::SquareOptions,
    Self::ZerosLikeOptions,
    Self::FillOptions,
    Self::BidirectionalSequenceLSTMOptions,
    Self::BidirectionalSequenceRNNOptions,
    Self::UnidirectionalSequenceLSTMOptions,
    Self::FloorModOptions,
    Self::RangeOptions,
    Self::ResizeNearestNeighborOptions,
    Self::LeakyReluOptions,
    Self::SquaredDifferenceOptions,
    Self::MirrorPadOptions,
    Self::AbsOptions,
    Self::SplitVOptions,
    Self::UniqueOptions,
    Self::ReverseV2Options,
    Self::AddNOptions,
    Self::GatherNdOptions,
    Self::CosOptions,
    Self::WhereOptions,
    Self::RankOptions,
    Self::ReverseSequenceOptions,
    Self::MatrixDiagOptions,
    Self::QuantizeOptions,
    Self::MatrixSetDiagOptions,
    Self::HardSwishOptions,
    Self::IfOptions,
    Self::WhileOptions,
    Self::DepthToSpaceOptions,
    Self::NonMaxSuppressionV4Options,
    Self::NonMaxSuppressionV5Options,
    Self::ScatterNdOptions,
    Self::SelectV2Options,
    Self::DensifyOptions,
    Self::SegmentSumOptions,
    Self::BatchMatMulOptions,
    Self::CumsumOptions,
    Self::CallOnceOptions,
    Self::BroadcastToOptions,
    Self::Rfft2dOptions,
    Self::Conv3DOptions,
    Self::HashtableOptions,
    Self::HashtableFindOptions,
    Self::HashtableImportOptions,
    Self::HashtableSizeOptions,
    Self::VarHandleOptions,
    Self::ReadVariableOptions,
    Self::AssignVariableOptions,
    Self::RandomOptions,
    Self::BucketizeOptions,
    Self::GeluOptions,
    Self::DynamicUpdateSliceOptions,
    Self::UnsortedSegmentProdOptions,
    Self::UnsortedSegmentMaxOptions,
    Self::UnsortedSegmentMinOptions,
    Self::UnsortedSegmentSumOptions,
    Self::ATan2Options,
    Self::SignOptions,
    Self::BitcastOptions,
    Self::BitwiseXorOptions,
    Self::RightShiftOptions,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Conv2DOptions => Some("Conv2DOptions"),
      Self::DepthwiseConv2DOptions => Some("DepthwiseConv2DOptions"),
      Self::ConcatEmbeddingsOptions => Some("ConcatEmbeddingsOptions"),
      Self::LSHProjectionOptions => Some("LSHProjectionOptions"),
      Self::Pool2DOptions => Some("Pool2DOptions"),
      Self::SVDFOptions => Some("SVDFOptions"),
      Self::RNNOptions => Some("RNNOptions"),
      Self::FullyConnectedOptions => Some("FullyConnectedOptions"),
      Self::SoftmaxOptions => Some("SoftmaxOptions"),
      Self::ConcatenationOptions => Some("ConcatenationOptions"),
      Self::AddOptions => Some("AddOptions"),
      Self::L2NormOptions => Some("L2NormOptions"),
      Self::LocalResponseNormalizationOptions => Some("LocalResponseNormalizationOptions"),
      Self::LSTMOptions => Some("LSTMOptions"),
      Self::ResizeBilinearOptions => Some("ResizeBilinearOptions"),
      Self::CallOptions => Some("CallOptions"),
      Self::ReshapeOptions => Some("ReshapeOptions"),
      Self::SkipGramOptions => Some("SkipGramOptions"),
      Self::SpaceToDepthOptions => Some("SpaceToDepthOptions"),
      Self::EmbeddingLookupSparseOptions => Some("EmbeddingLookupSparseOptions"),
      Self::MulOptions => Some("MulOptions"),
      Self::PadOptions => Some("PadOptions"),
      Self::GatherOptions => Some("GatherOptions"),
      Self::BatchToSpaceNDOptions => Some("BatchToSpaceNDOptions"),
      Self::SpaceToBatchNDOptions => Some("SpaceToBatchNDOptions"),
      Self::TransposeOptions => Some("TransposeOptions"),
      Self::ReducerOptions => Some("ReducerOptions"),
      Self::SubOptions => Some("SubOptions"),
      Self::DivOptions => Some("DivOptions"),
      Self::SqueezeOptions => Some("SqueezeOptions"),
      Self::SequenceRNNOptions => Some("SequenceRNNOptions"),
      Self::StridedSliceOptions => Some("StridedSliceOptions"),
      Self::ExpOptions => Some("ExpOptions"),
      Self::TopKV2Options => Some("TopKV2Options"),
      Self::SplitOptions => Some("SplitOptions"),
      Self::LogSoftmaxOptions => Some("LogSoftmaxOptions"),
      Self::CastOptions => Some("CastOptions"),
      Self::DequantizeOptions => Some("DequantizeOptions"),
      Self::MaximumMinimumOptions => Some("MaximumMinimumOptions"),
      Self::ArgMaxOptions => Some("ArgMaxOptions"),
      Self::LessOptions => Some("LessOptions"),
      Self::NegOptions => Some("NegOptions"),
      Self::PadV2Options => Some("PadV2Options"),
      Self::GreaterOptions => Some("GreaterOptions"),
      Self::GreaterEqualOptions => Some("GreaterEqualOptions"),
      Self::LessEqualOptions => Some("LessEqualOptions"),
      Self::SelectOptions => Some("SelectOptions"),
      Self::SliceOptions => Some("SliceOptions"),
      Self::TransposeConvOptions => Some("TransposeConvOptions"),
      Self::SparseToDenseOptions => Some("SparseToDenseOptions"),
      Self::TileOptions => Some("TileOptions"),
      Self::ExpandDimsOptions => Some("ExpandDimsOptions"),
      Self::EqualOptions => Some("EqualOptions"),
      Self::NotEqualOptions => Some("NotEqualOptions"),
      Self::ShapeOptions => Some("ShapeOptions"),
      Self::PowOptions => Some("PowOptions"),
      Self::ArgMinOptions => Some("ArgMinOptions"),
      Self::FakeQuantOptions => Some("FakeQuantOptions"),
      Self::PackOptions => Some("PackOptions"),
      Self::LogicalOrOptions => Some("LogicalOrOptions"),
      Self::OneHotOptions => Some("OneHotOptions"),
      Self::LogicalAndOptions => Some("LogicalAndOptions"),
      Self::LogicalNotOptions => Some("LogicalNotOptions"),
      Self::UnpackOptions => Some("UnpackOptions"),
      Self::FloorDivOptions => Some("FloorDivOptions"),
      Self::SquareOptions => Some("SquareOptions"),
      Self::ZerosLikeOptions => Some("ZerosLikeOptions"),
      Self::FillOptions => Some("FillOptions"),
      Self::BidirectionalSequenceLSTMOptions => Some("BidirectionalSequenceLSTMOptions"),
      Self::BidirectionalSequenceRNNOptions => Some("BidirectionalSequenceRNNOptions"),
      Self::UnidirectionalSequenceLSTMOptions => Some("UnidirectionalSequenceLSTMOptions"),
      Self::FloorModOptions => Some("FloorModOptions"),
      Self::RangeOptions => Some("RangeOptions"),
      Self::ResizeNearestNeighborOptions => Some("ResizeNearestNeighborOptions"),
      Self::LeakyReluOptions => Some("LeakyReluOptions"),
      Self::SquaredDifferenceOptions => Some("SquaredDifferenceOptions"),
      Self::MirrorPadOptions => Some("MirrorPadOptions"),
      Self::AbsOptions => Some("AbsOptions"),
      Self::SplitVOptions => Some("SplitVOptions"),
      Self::UniqueOptions => Some("UniqueOptions"),
      Self::ReverseV2Options => Some("ReverseV2Options"),
      Self::AddNOptions => Some("AddNOptions"),
      Self::GatherNdOptions => Some("GatherNdOptions"),
      Self::CosOptions => Some("CosOptions"),
      Self::WhereOptions => Some("WhereOptions"),
      Self::RankOptions => Some("RankOptions"),
      Self::ReverseSequenceOptions => Some("ReverseSequenceOptions"),
      Self::MatrixDiagOptions => Some("MatrixDiagOptions"),
      Self::QuantizeOptions => Some("QuantizeOptions"),
      Self::MatrixSetDiagOptions => Some("MatrixSetDiagOptions"),
      Self::HardSwishOptions => Some("HardSwishOptions"),
      Self::IfOptions => Some("IfOptions"),
      Self::WhileOptions => Some("WhileOptions"),
      Self::DepthToSpaceOptions => Some("DepthToSpaceOptions"),
      Self::NonMaxSuppressionV4Options => Some("NonMaxSuppressionV4Options"),
      Self::NonMaxSuppressionV5Options => Some("NonMaxSuppressionV5Options"),
      Self::ScatterNdOptions => Some("ScatterNdOptions"),
      Self::SelectV2Options => Some("SelectV2Options"),
      Self::DensifyOptions => Some("DensifyOptions"),
      Self::SegmentSumOptions => Some("SegmentSumOptions"),
      Self::BatchMatMulOptions => Some("BatchMatMulOptions"),
      Self::CumsumOptions => Some("CumsumOptions"),
      Self::CallOnceOptions => Some("CallOnceOptions"),
      Self::BroadcastToOptions => Some("BroadcastToOptions"),
      Self::Rfft2dOptions => Some("Rfft2dOptions"),
      Self::Conv3DOptions => Some("Conv3DOptions"),
      Self::HashtableOptions => Some("HashtableOptions"),
      Self::HashtableFindOptions => Some("HashtableFindOptions"),
      Self::HashtableImportOptions => Some("HashtableImportOptions"),
      Self::HashtableSizeOptions => Some("HashtableSizeOptions"),
      Self::VarHandleOptions => Some("VarHandleOptions"),
      Self::ReadVariableOptions => Some("ReadVariableOptions"),
      Self::AssignVariableOptions => Some("AssignVariableOptions"),
      Self::RandomOptions => Some("RandomOptions"),
      Self::BucketizeOptions => Some("BucketizeOptions"),
      Self::GeluOptions => Some("GeluOptions"),
      Self::DynamicUpdateSliceOptions => Some("DynamicUpdateSliceOptions"),
      Self::UnsortedSegmentProdOptions => Some("UnsortedSegmentProdOptions"),
      Self::UnsortedSegmentMaxOptions => Some("UnsortedSegmentMaxOptions"),
      Self::UnsortedSegmentMinOptions => Some("UnsortedSegmentMinOptions"),
      Self::UnsortedSegmentSumOptions => Some("UnsortedSegmentSumOptions"),
      Self::ATan2Options => Some("ATan2Options"),
      Self::SignOptions => Some("SignOptions"),
      Self::BitcastOptions => Some("BitcastOptions"),
      Self::BitwiseXorOptions => Some("BitwiseXorOptions"),
      Self::RightShiftOptions => Some("RightShiftOptions"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BuiltinOptions {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BuiltinOptions {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BuiltinOptions {
    type Output = BuiltinOptions;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BuiltinOptions {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BuiltinOptions {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BuiltinOptions {}
pub struct BuiltinOptionsUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PADDING: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PADDING: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PADDING: [Padding; 2] = [
  Padding::SAME,
  Padding::VALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Padding(pub i8);
#[allow(non_upper_case_globals)]
impl Padding {
  pub const SAME: Self = Self(0);
  pub const VALID: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SAME,
    Self::VALID,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SAME => Some("SAME"),
      Self::VALID => Some("VALID"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Padding {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Padding {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Padding {
    type Output = Padding;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Padding {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Padding {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Padding {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTIVATION_FUNCTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTIVATION_FUNCTION_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTIVATION_FUNCTION_TYPE: [ActivationFunctionType; 6] = [
  ActivationFunctionType::NONE,
  ActivationFunctionType::RELU,
  ActivationFunctionType::RELU_N1_TO_1,
  ActivationFunctionType::RELU6,
  ActivationFunctionType::TANH,
  ActivationFunctionType::SIGN_BIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ActivationFunctionType(pub i8);
#[allow(non_upper_case_globals)]
impl ActivationFunctionType {
  pub const NONE: Self = Self(0);
  pub const RELU: Self = Self(1);
  pub const RELU_N1_TO_1: Self = Self(2);
  pub const RELU6: Self = Self(3);
  pub const TANH: Self = Self(4);
  pub const SIGN_BIT: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::RELU,
    Self::RELU_N1_TO_1,
    Self::RELU6,
    Self::TANH,
    Self::SIGN_BIT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::RELU => Some("RELU"),
      Self::RELU_N1_TO_1 => Some("RELU_N1_TO_1"),
      Self::RELU6 => Some("RELU6"),
      Self::TANH => Some("TANH"),
      Self::SIGN_BIT => Some("SIGN_BIT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ActivationFunctionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ActivationFunctionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ActivationFunctionType {
    type Output = ActivationFunctionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ActivationFunctionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ActivationFunctionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ActivationFunctionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LSHPROJECTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LSHPROJECTION_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LSHPROJECTION_TYPE: [LSHProjectionType; 3] = [
  LSHProjectionType::UNKNOWN,
  LSHProjectionType::SPARSE,
  LSHProjectionType::DENSE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LSHProjectionType(pub i8);
#[allow(non_upper_case_globals)]
impl LSHProjectionType {
  pub const UNKNOWN: Self = Self(0);
  pub const SPARSE: Self = Self(1);
  pub const DENSE: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::SPARSE,
    Self::DENSE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::SPARSE => Some("SPARSE"),
      Self::DENSE => Some("DENSE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LSHProjectionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LSHProjectionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LSHProjectionType {
    type Output = LSHProjectionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LSHProjectionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LSHProjectionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LSHProjectionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: [FullyConnectedOptionsWeightsFormat; 2] = [
  FullyConnectedOptionsWeightsFormat::DEFAULT,
  FullyConnectedOptionsWeightsFormat::SHUFFLED4x16INT8,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FullyConnectedOptionsWeightsFormat(pub i8);
#[allow(non_upper_case_globals)]
impl FullyConnectedOptionsWeightsFormat {
  pub const DEFAULT: Self = Self(0);
  pub const SHUFFLED4x16INT8: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::SHUFFLED4x16INT8,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DEFAULT => Some("DEFAULT"),
      Self::SHUFFLED4x16INT8 => Some("SHUFFLED4x16INT8"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FullyConnectedOptionsWeightsFormat {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FullyConnectedOptionsWeightsFormat {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FullyConnectedOptionsWeightsFormat {
    type Output = FullyConnectedOptionsWeightsFormat;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FullyConnectedOptionsWeightsFormat {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FullyConnectedOptionsWeightsFormat {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FullyConnectedOptionsWeightsFormat {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LSTMKERNEL_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LSTMKERNEL_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LSTMKERNEL_TYPE: [LSTMKernelType; 2] = [
  LSTMKernelType::FULL,
  LSTMKernelType::BASIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LSTMKernelType(pub i8);
#[allow(non_upper_case_globals)]
impl LSTMKernelType {
  pub const FULL: Self = Self(0);
  pub const BASIC: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FULL,
    Self::BASIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FULL => Some("FULL"),
      Self::BASIC => Some("BASIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LSTMKernelType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LSTMKernelType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LSTMKernelType {
    type Output = LSTMKernelType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LSTMKernelType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LSTMKernelType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LSTMKernelType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMBINER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMBINER_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMBINER_TYPE: [CombinerType; 3] = [
  CombinerType::SUM,
  CombinerType::MEAN,
  CombinerType::SQRTN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CombinerType(pub i8);
#[allow(non_upper_case_globals)]
impl CombinerType {
  pub const SUM: Self = Self(0);
  pub const MEAN: Self = Self(1);
  pub const SQRTN: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SUM,
    Self::MEAN,
    Self::SQRTN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SUM => Some("SUM"),
      Self::MEAN => Some("MEAN"),
      Self::SQRTN => Some("SQRTN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CombinerType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CombinerType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CombinerType {
    type Output = CombinerType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CombinerType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CombinerType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CombinerType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MIRROR_PAD_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MIRROR_PAD_MODE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MIRROR_PAD_MODE: [MirrorPadMode; 2] = [
  MirrorPadMode::REFLECT,
  MirrorPadMode::SYMMETRIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MirrorPadMode(pub i8);
#[allow(non_upper_case_globals)]
impl MirrorPadMode {
  pub const REFLECT: Self = Self(0);
  pub const SYMMETRIC: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REFLECT,
    Self::SYMMETRIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REFLECT => Some("REFLECT"),
      Self::SYMMETRIC => Some("SYMMETRIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MirrorPadMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MirrorPadMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MirrorPadMode {
    type Output = MirrorPadMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MirrorPadMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MirrorPadMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MirrorPadMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CUSTOM_OPTIONS_FORMAT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CUSTOM_OPTIONS_FORMAT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CUSTOM_OPTIONS_FORMAT: [CustomOptionsFormat; 1] = [
  CustomOptionsFormat::FLEXBUFFERS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CustomOptionsFormat(pub i8);
#[allow(non_upper_case_globals)]
impl CustomOptionsFormat {
  pub const FLEXBUFFERS: Self = Self(0);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FLEXBUFFERS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FLEXBUFFERS => Some("FLEXBUFFERS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CustomOptionsFormat {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CustomOptionsFormat {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CustomOptionsFormat {
    type Output = CustomOptionsFormat;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CustomOptionsFormat {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CustomOptionsFormat {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CustomOptionsFormat {}
pub enum CustomQuantizationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CustomQuantization<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomQuantization<'a> {
  type Inner = CustomQuantization<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CustomQuantization<'a> {
  pub const VT_CUSTOM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CustomQuantization { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CustomQuantizationArgs<'args>
  ) -> flatbuffers::WIPOffset<CustomQuantization<'bldr>> {
    let mut builder = CustomQuantizationBuilder::new(_fbb);
    if let Some(x) = args.custom { builder.add_custom(x); }
    builder.finish()
  }


  #[inline]
  pub fn custom(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CustomQuantization::VT_CUSTOM, None)}
  }
}

impl flatbuffers::Verifiable for CustomQuantization<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("custom", Self::VT_CUSTOM, false)?
     .finish();
    Ok(())
  }
}
pub struct CustomQuantizationArgs<'a> {
    pub custom: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CustomQuantizationArgs<'a> {
  #[inline]
  fn default() -> Self {
    CustomQuantizationArgs {
      custom: None,
    }
  }
}

pub struct CustomQuantizationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CustomQuantizationBuilder<'a, 'b> {
  #[inline]
  pub fn add_custom(&mut self, custom: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomQuantization::VT_CUSTOM, custom);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CustomQuantizationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CustomQuantizationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomQuantization<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CustomQuantization<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CustomQuantization");
      ds.field("custom", &self.custom());
      ds.finish()
  }
}
pub enum QuantizationParametersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuantizationParameters<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuantizationParameters<'a> {
  type Inner = QuantizationParameters<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QuantizationParameters<'a> {
  pub const VT_MIN: flatbuffers::VOffsetT = 4;
  pub const VT_MAX: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE: flatbuffers::VOffsetT = 8;
  pub const VT_ZERO_POINT: flatbuffers::VOffsetT = 10;
  pub const VT_DETAILS_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_DETAILS: flatbuffers::VOffsetT = 14;
  pub const VT_QUANTIZED_DIMENSION: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuantizationParameters { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args QuantizationParametersArgs<'args>
  ) -> flatbuffers::WIPOffset<QuantizationParameters<'bldr>> {
    let mut builder = QuantizationParametersBuilder::new(_fbb);
    builder.add_quantized_dimension(args.quantized_dimension);
    if let Some(x) = args.details { builder.add_details(x); }
    if let Some(x) = args.zero_point { builder.add_zero_point(x); }
    if let Some(x) = args.scale { builder.add_scale(x); }
    if let Some(x) = args.max { builder.add_max(x); }
    if let Some(x) = args.min { builder.add_min(x); }
    builder.add_details_type(args.details_type);
    builder.finish()
  }


  #[inline]
  pub fn min(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(QuantizationParameters::VT_MIN, None)}
  }
  #[inline]
  pub fn max(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(QuantizationParameters::VT_MAX, None)}
  }
  #[inline]
  pub fn scale(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(QuantizationParameters::VT_SCALE, None)}
  }
  #[inline]
  pub fn zero_point(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(QuantizationParameters::VT_ZERO_POINT, None)}
  }
  #[inline]
  pub fn details_type(&self) -> QuantizationDetails {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<QuantizationDetails>(QuantizationParameters::VT_DETAILS_TYPE, Some(QuantizationDetails::NONE)).unwrap()}
  }
  #[inline]
  pub fn details(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(QuantizationParameters::VT_DETAILS, None)}
  }
  #[inline]
  pub fn quantized_dimension(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(QuantizationParameters::VT_QUANTIZED_DIMENSION, Some(0)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_custom_quantization(&self) -> Option<CustomQuantization<'a>> {
    if self.details_type() == QuantizationDetails::CustomQuantization {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CustomQuantization::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for QuantizationParameters<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("min", Self::VT_MIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("max", Self::VT_MAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("scale", Self::VT_SCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("zero_point", Self::VT_ZERO_POINT, false)?
     .visit_union::<QuantizationDetails, _>("details_type", Self::VT_DETAILS_TYPE, "details", Self::VT_DETAILS, false, |key, v, pos| {
        match key {
          QuantizationDetails::CustomQuantization => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CustomQuantization>>("QuantizationDetails::CustomQuantization", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<i32>("quantized_dimension", Self::VT_QUANTIZED_DIMENSION, false)?
     .finish();
    Ok(())
  }
}
pub struct QuantizationParametersArgs<'a> {
    pub min: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub max: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub scale: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub zero_point: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub details_type: QuantizationDetails,
    pub details: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub quantized_dimension: i32,
}
impl<'a> Default for QuantizationParametersArgs<'a> {
  #[inline]
  fn default() -> Self {
    QuantizationParametersArgs {
      min: None,
      max: None,
      scale: None,
      zero_point: None,
      details_type: QuantizationDetails::NONE,
      details: None,
      quantized_dimension: 0,
    }
  }
}

pub struct QuantizationParametersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuantizationParametersBuilder<'a, 'b> {
  #[inline]
  pub fn add_min(&mut self, min: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_MIN, min);
  }
  #[inline]
  pub fn add_max(&mut self, max: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_MAX, max);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_SCALE, scale);
  }
  #[inline]
  pub fn add_zero_point(&mut self, zero_point: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  #[inline]
  pub fn add_details_type(&mut self, details_type: QuantizationDetails) {
    self.fbb_.push_slot::<QuantizationDetails>(QuantizationParameters::VT_DETAILS_TYPE, details_type, QuantizationDetails::NONE);
  }
  #[inline]
  pub fn add_details(&mut self, details: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_DETAILS, details);
  }
  #[inline]
  pub fn add_quantized_dimension(&mut self, quantized_dimension: i32) {
    self.fbb_.push_slot::<i32>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuantizationParametersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuantizationParametersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuantizationParameters<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuantizationParameters<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuantizationParameters");
      ds.field("min", &self.min());
      ds.field("max", &self.max());
      ds.field("scale", &self.scale());
      ds.field("zero_point", &self.zero_point());
      ds.field("details_type", &self.details_type());
      match self.details_type() {
        QuantizationDetails::CustomQuantization => {
          if let Some(x) = self.details_as_custom_quantization() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("details", &x)
        },
      };
      ds.field("quantized_dimension", &self.quantized_dimension());
      ds.finish()
  }
}
pub enum Int32VectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int32Vector<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int32Vector<'a> {
  type Inner = Int32Vector<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Int32Vector<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Int32Vector { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Int32VectorArgs<'args>
  ) -> flatbuffers::WIPOffset<Int32Vector<'bldr>> {
    let mut builder = Int32VectorBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Int32Vector::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for Int32Vector<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct Int32VectorArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for Int32VectorArgs<'a> {
  #[inline]
  fn default() -> Self {
    Int32VectorArgs {
      values: None,
    }
  }
}

pub struct Int32VectorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int32VectorBuilder<'a, 'b> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int32Vector::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int32VectorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int32VectorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int32Vector<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Int32Vector<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Int32Vector");
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum Uint16VectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint16Vector<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint16Vector<'a> {
  type Inner = Uint16Vector<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Uint16Vector<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Uint16Vector { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Uint16VectorArgs<'args>
  ) -> flatbuffers::WIPOffset<Uint16Vector<'bldr>> {
    let mut builder = Uint16VectorBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Uint16Vector::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for Uint16Vector<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint16VectorArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for Uint16VectorArgs<'a> {
  #[inline]
  fn default() -> Self {
    Uint16VectorArgs {
      values: None,
    }
  }
}

pub struct Uint16VectorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint16VectorBuilder<'a, 'b> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint16Vector::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint16VectorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint16VectorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint16Vector<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Uint16Vector<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Uint16Vector");
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum Uint8VectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint8Vector<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint8Vector<'a> {
  type Inner = Uint8Vector<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Uint8Vector<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Uint8Vector { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Uint8VectorArgs<'args>
  ) -> flatbuffers::WIPOffset<Uint8Vector<'bldr>> {
    let mut builder = Uint8VectorBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Uint8Vector::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for Uint8Vector<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint8VectorArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for Uint8VectorArgs<'a> {
  #[inline]
  fn default() -> Self {
    Uint8VectorArgs {
      values: None,
    }
  }
}

pub struct Uint8VectorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint8VectorBuilder<'a, 'b> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint8Vector::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint8VectorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint8VectorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint8Vector<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Uint8Vector<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Uint8Vector");
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum DimensionMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionMetadata<'a> {
  type Inner = DimensionMetadata<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionMetadata<'a> {
  pub const VT_FORMAT: flatbuffers::VOffsetT = 4;
  pub const VT_DENSE_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_ARRAY_SEGMENTS_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ARRAY_SEGMENTS: flatbuffers::VOffsetT = 10;
  pub const VT_ARRAY_INDICES_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_ARRAY_INDICES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionMetadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DimensionMetadataArgs
  ) -> flatbuffers::WIPOffset<DimensionMetadata<'bldr>> {
    let mut builder = DimensionMetadataBuilder::new(_fbb);
    if let Some(x) = args.array_indices { builder.add_array_indices(x); }
    if let Some(x) = args.array_segments { builder.add_array_segments(x); }
    builder.add_dense_size(args.dense_size);
    builder.add_array_indices_type(args.array_indices_type);
    builder.add_array_segments_type(args.array_segments_type);
    builder.add_format(args.format);
    builder.finish()
  }


  #[inline]
  pub fn format(&self) -> DimensionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DimensionType>(DimensionMetadata::VT_FORMAT, Some(DimensionType::DENSE)).unwrap()}
  }
  #[inline]
  pub fn dense_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DimensionMetadata::VT_DENSE_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn array_segments_type(&self) -> SparseIndexVector {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SparseIndexVector>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, Some(SparseIndexVector::NONE)).unwrap()}
  }
  #[inline]
  pub fn array_segments(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DimensionMetadata::VT_ARRAY_SEGMENTS, None)}
  }
  #[inline]
  pub fn array_indices_type(&self) -> SparseIndexVector {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SparseIndexVector>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, Some(SparseIndexVector::NONE)).unwrap()}
  }
  #[inline]
  pub fn array_indices(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DimensionMetadata::VT_ARRAY_INDICES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn array_segments_as_int_32_vector(&self) -> Option<Int32Vector<'a>> {
    if self.array_segments_type() == SparseIndexVector::Int32Vector {
      self.array_segments().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Int32Vector::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_segments_as_uint_16_vector(&self) -> Option<Uint16Vector<'a>> {
    if self.array_segments_type() == SparseIndexVector::Uint16Vector {
      self.array_segments().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Uint16Vector::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_segments_as_uint_8_vector(&self) -> Option<Uint8Vector<'a>> {
    if self.array_segments_type() == SparseIndexVector::Uint8Vector {
      self.array_segments().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Uint8Vector::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_indices_as_int_32_vector(&self) -> Option<Int32Vector<'a>> {
    if self.array_indices_type() == SparseIndexVector::Int32Vector {
      self.array_indices().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Int32Vector::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_indices_as_uint_16_vector(&self) -> Option<Uint16Vector<'a>> {
    if self.array_indices_type() == SparseIndexVector::Uint16Vector {
      self.array_indices().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Uint16Vector::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn array_indices_as_uint_8_vector(&self) -> Option<Uint8Vector<'a>> {
    if self.array_indices_type() == SparseIndexVector::Uint8Vector {
      self.array_indices().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Uint8Vector::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DimensionMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DimensionType>("format", Self::VT_FORMAT, false)?
     .visit_field::<i32>("dense_size", Self::VT_DENSE_SIZE, false)?
     .visit_union::<SparseIndexVector, _>("array_segments_type", Self::VT_ARRAY_SEGMENTS_TYPE, "array_segments", Self::VT_ARRAY_SEGMENTS, false, |key, v, pos| {
        match key {
          SparseIndexVector::Int32Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Int32Vector>>("SparseIndexVector::Int32Vector", pos),
          SparseIndexVector::Uint16Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Uint16Vector>>("SparseIndexVector::Uint16Vector", pos),
          SparseIndexVector::Uint8Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Uint8Vector>>("SparseIndexVector::Uint8Vector", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SparseIndexVector, _>("array_indices_type", Self::VT_ARRAY_INDICES_TYPE, "array_indices", Self::VT_ARRAY_INDICES, false, |key, v, pos| {
        match key {
          SparseIndexVector::Int32Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Int32Vector>>("SparseIndexVector::Int32Vector", pos),
          SparseIndexVector::Uint16Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Uint16Vector>>("SparseIndexVector::Uint16Vector", pos),
          SparseIndexVector::Uint8Vector => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Uint8Vector>>("SparseIndexVector::Uint8Vector", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DimensionMetadataArgs {
    pub format: DimensionType,
    pub dense_size: i32,
    pub array_segments_type: SparseIndexVector,
    pub array_segments: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub array_indices_type: SparseIndexVector,
    pub array_indices: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DimensionMetadataArgs {
  #[inline]
  fn default() -> Self {
    DimensionMetadataArgs {
      format: DimensionType::DENSE,
      dense_size: 0,
      array_segments_type: SparseIndexVector::NONE,
      array_segments: None,
      array_indices_type: SparseIndexVector::NONE,
      array_indices: None,
    }
  }
}

pub struct DimensionMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DimensionMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_format(&mut self, format: DimensionType) {
    self.fbb_.push_slot::<DimensionType>(DimensionMetadata::VT_FORMAT, format, DimensionType::DENSE);
  }
  #[inline]
  pub fn add_dense_size(&mut self, dense_size: i32) {
    self.fbb_.push_slot::<i32>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  #[inline]
  pub fn add_array_segments_type(&mut self, array_segments_type: SparseIndexVector) {
    self.fbb_.push_slot::<SparseIndexVector>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, array_segments_type, SparseIndexVector::NONE);
  }
  #[inline]
  pub fn add_array_segments(&mut self, array_segments: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  #[inline]
  pub fn add_array_indices_type(&mut self, array_indices_type: SparseIndexVector) {
    self.fbb_.push_slot::<SparseIndexVector>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, array_indices_type, SparseIndexVector::NONE);
  }
  #[inline]
  pub fn add_array_indices(&mut self, array_indices: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DimensionMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DimensionMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionMetadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionMetadata");
      ds.field("format", &self.format());
      ds.field("dense_size", &self.dense_size());
      ds.field("array_segments_type", &self.array_segments_type());
      match self.array_segments_type() {
        SparseIndexVector::Int32Vector => {
          if let Some(x) = self.array_segments_as_int_32_vector() {
            ds.field("array_segments", &x)
          } else {
            ds.field("array_segments", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SparseIndexVector::Uint16Vector => {
          if let Some(x) = self.array_segments_as_uint_16_vector() {
            ds.field("array_segments", &x)
          } else {
            ds.field("array_segments", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SparseIndexVector::Uint8Vector => {
          if let Some(x) = self.array_segments_as_uint_8_vector() {
            ds.field("array_segments", &x)
          } else {
            ds.field("array_segments", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("array_segments", &x)
        },
      };
      ds.field("array_indices_type", &self.array_indices_type());
      match self.array_indices_type() {
        SparseIndexVector::Int32Vector => {
          if let Some(x) = self.array_indices_as_int_32_vector() {
            ds.field("array_indices", &x)
          } else {
            ds.field("array_indices", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SparseIndexVector::Uint16Vector => {
          if let Some(x) = self.array_indices_as_uint_16_vector() {
            ds.field("array_indices", &x)
          } else {
            ds.field("array_indices", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SparseIndexVector::Uint8Vector => {
          if let Some(x) = self.array_indices_as_uint_8_vector() {
            ds.field("array_indices", &x)
          } else {
            ds.field("array_indices", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("array_indices", &x)
        },
      };
      ds.finish()
  }
}
pub enum SparsityParametersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparsityParameters<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparsityParameters<'a> {
  type Inner = SparsityParameters<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SparsityParameters<'a> {
  pub const VT_TRAVERSAL_ORDER: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_MAP: flatbuffers::VOffsetT = 6;
  pub const VT_DIM_METADATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparsityParameters { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SparsityParametersArgs<'args>
  ) -> flatbuffers::WIPOffset<SparsityParameters<'bldr>> {
    let mut builder = SparsityParametersBuilder::new(_fbb);
    if let Some(x) = args.dim_metadata { builder.add_dim_metadata(x); }
    if let Some(x) = args.block_map { builder.add_block_map(x); }
    if let Some(x) = args.traversal_order { builder.add_traversal_order(x); }
    builder.finish()
  }


  #[inline]
  pub fn traversal_order(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SparsityParameters::VT_TRAVERSAL_ORDER, None)}
  }
  #[inline]
  pub fn block_map(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SparsityParameters::VT_BLOCK_MAP, None)}
  }
  #[inline]
  pub fn dim_metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionMetadata<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionMetadata>>>>(SparsityParameters::VT_DIM_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for SparsityParameters<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("traversal_order", Self::VT_TRAVERSAL_ORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("block_map", Self::VT_BLOCK_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DimensionMetadata>>>>("dim_metadata", Self::VT_DIM_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct SparsityParametersArgs<'a> {
    pub traversal_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub block_map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub dim_metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionMetadata<'a>>>>>,
}
impl<'a> Default for SparsityParametersArgs<'a> {
  #[inline]
  fn default() -> Self {
    SparsityParametersArgs {
      traversal_order: None,
      block_map: None,
      dim_metadata: None,
    }
  }
}

pub struct SparsityParametersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SparsityParametersBuilder<'a, 'b> {
  #[inline]
  pub fn add_traversal_order(&mut self, traversal_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  #[inline]
  pub fn add_block_map(&mut self, block_map: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  #[inline]
  pub fn add_dim_metadata(&mut self, dim_metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DimensionMetadata<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SparsityParametersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SparsityParametersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparsityParameters<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparsityParameters<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparsityParameters");
      ds.field("traversal_order", &self.traversal_order());
      ds.field("block_map", &self.block_map());
      ds.field("dim_metadata", &self.dim_metadata());
      ds.finish()
  }
}
pub enum VariantSubTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VariantSubType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VariantSubType<'a> {
  type Inner = VariantSubType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VariantSubType<'a> {
  pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_HAS_RANK: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VariantSubType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VariantSubTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<VariantSubType<'bldr>> {
    let mut builder = VariantSubTypeBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_has_rank(args.has_rank);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(VariantSubType::VT_SHAPE, None)}
  }
  #[inline]
  pub fn type_(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(VariantSubType::VT_TYPE_, Some(TensorType::FLOAT32)).unwrap()}
  }
  #[inline]
  pub fn has_rank(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(VariantSubType::VT_HAS_RANK, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VariantSubType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("shape", Self::VT_SHAPE, false)?
     .visit_field::<TensorType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<bool>("has_rank", Self::VT_HAS_RANK, false)?
     .finish();
    Ok(())
  }
}
pub struct VariantSubTypeArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub type_: TensorType,
    pub has_rank: bool,
}
impl<'a> Default for VariantSubTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariantSubTypeArgs {
      shape: None,
      type_: TensorType::FLOAT32,
      has_rank: false,
    }
  }
}

pub struct VariantSubTypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VariantSubTypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariantSubType::VT_SHAPE, shape);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: TensorType) {
    self.fbb_.push_slot::<TensorType>(VariantSubType::VT_TYPE_, type_, TensorType::FLOAT32);
  }
  #[inline]
  pub fn add_has_rank(&mut self, has_rank: bool) {
    self.fbb_.push_slot::<bool>(VariantSubType::VT_HAS_RANK, has_rank, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VariantSubTypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VariantSubTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VariantSubType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VariantSubType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VariantSubType");
      ds.field("shape", &self.shape());
      ds.field("type_", &self.type_());
      ds.field("has_rank", &self.has_rank());
      ds.finish()
  }
}
pub enum TensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
  type Inner = Tensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tensor<'a> {
  pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_BUFFER: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_QUANTIZATION: flatbuffers::VOffsetT = 12;
  pub const VT_IS_VARIABLE: flatbuffers::VOffsetT = 14;
  pub const VT_SPARSITY: flatbuffers::VOffsetT = 16;
  pub const VT_SHAPE_SIGNATURE: flatbuffers::VOffsetT = 18;
  pub const VT_HAS_RANK: flatbuffers::VOffsetT = 20;
  pub const VT_VARIANT_TENSORS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorArgs<'args>
  ) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
    let mut builder = TensorBuilder::new(_fbb);
    if let Some(x) = args.variant_tensors { builder.add_variant_tensors(x); }
    if let Some(x) = args.shape_signature { builder.add_shape_signature(x); }
    if let Some(x) = args.sparsity { builder.add_sparsity(x); }
    if let Some(x) = args.quantization { builder.add_quantization(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_buffer(args.buffer);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_has_rank(args.has_rank);
    builder.add_is_variable(args.is_variable);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Tensor::VT_SHAPE, None)}
  }
  #[inline]
  pub fn type_(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(Tensor::VT_TYPE_, Some(TensorType::FLOAT32)).unwrap()}
  }
  #[inline]
  pub fn buffer(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Tensor::VT_BUFFER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tensor::VT_NAME, None)}
  }
  #[inline]
  pub fn quantization(&self) -> Option<QuantizationParameters<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<QuantizationParameters>>(Tensor::VT_QUANTIZATION, None)}
  }
  #[inline]
  pub fn is_variable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Tensor::VT_IS_VARIABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sparsity(&self) -> Option<SparsityParameters<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SparsityParameters>>(Tensor::VT_SPARSITY, None)}
  }
  #[inline]
  pub fn shape_signature(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Tensor::VT_SHAPE_SIGNATURE, None)}
  }
  #[inline]
  pub fn has_rank(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Tensor::VT_HAS_RANK, Some(false)).unwrap()}
  }
  #[inline]
  pub fn variant_tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantSubType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantSubType>>>>(Tensor::VT_VARIANT_TENSORS, None)}
  }
}

impl flatbuffers::Verifiable for Tensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("shape", Self::VT_SHAPE, false)?
     .visit_field::<TensorType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u32>("buffer", Self::VT_BUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<QuantizationParameters>>("quantization", Self::VT_QUANTIZATION, false)?
     .visit_field::<bool>("is_variable", Self::VT_IS_VARIABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SparsityParameters>>("sparsity", Self::VT_SPARSITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("shape_signature", Self::VT_SHAPE_SIGNATURE, false)?
     .visit_field::<bool>("has_rank", Self::VT_HAS_RANK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VariantSubType>>>>("variant_tensors", Self::VT_VARIANT_TENSORS, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub type_: TensorType,
    pub buffer: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quantization: Option<flatbuffers::WIPOffset<QuantizationParameters<'a>>>,
    pub is_variable: bool,
    pub sparsity: Option<flatbuffers::WIPOffset<SparsityParameters<'a>>>,
    pub shape_signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub has_rank: bool,
    pub variant_tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantSubType<'a>>>>>,
}
impl<'a> Default for TensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorArgs {
      shape: None,
      type_: TensorType::FLOAT32,
      buffer: 0,
      name: None,
      quantization: None,
      is_variable: false,
      sparsity: None,
      shape_signature: None,
      has_rank: false,
      variant_tensors: None,
    }
  }
}

pub struct TensorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE, shape);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: TensorType) {
    self.fbb_.push_slot::<TensorType>(Tensor::VT_TYPE_, type_, TensorType::FLOAT32);
  }
  #[inline]
  pub fn add_buffer(&mut self, buffer: u32) {
    self.fbb_.push_slot::<u32>(Tensor::VT_BUFFER, buffer, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_NAME, name);
  }
  #[inline]
  pub fn add_quantization(&mut self, quantization: flatbuffers::WIPOffset<QuantizationParameters<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<QuantizationParameters>>(Tensor::VT_QUANTIZATION, quantization);
  }
  #[inline]
  pub fn add_is_variable(&mut self, is_variable: bool) {
    self.fbb_.push_slot::<bool>(Tensor::VT_IS_VARIABLE, is_variable, false);
  }
  #[inline]
  pub fn add_sparsity(&mut self, sparsity: flatbuffers::WIPOffset<SparsityParameters<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SparsityParameters>>(Tensor::VT_SPARSITY, sparsity);
  }
  #[inline]
  pub fn add_shape_signature(&mut self, shape_signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  #[inline]
  pub fn add_has_rank(&mut self, has_rank: bool) {
    self.fbb_.push_slot::<bool>(Tensor::VT_HAS_RANK, has_rank, false);
  }
  #[inline]
  pub fn add_variant_tensors(&mut self, variant_tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VariantSubType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_VARIANT_TENSORS, variant_tensors);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tensor");
      ds.field("shape", &self.shape());
      ds.field("type_", &self.type_());
      ds.field("buffer", &self.buffer());
      ds.field("name", &self.name());
      ds.field("quantization", &self.quantization());
      ds.field("is_variable", &self.is_variable());
      ds.field("sparsity", &self.sparsity());
      ds.field("shape_signature", &self.shape_signature());
      ds.field("has_rank", &self.has_rank());
      ds.field("variant_tensors", &self.variant_tensors());
      ds.finish()
  }
}
pub enum Conv2DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Conv2DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Conv2DOptions<'a> {
  type Inner = Conv2DOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Conv2DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 10;
  pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 12;
  pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Conv2DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Conv2DOptionsArgs
  ) -> flatbuffers::WIPOffset<Conv2DOptions<'bldr>> {
    let mut builder = Conv2DOptionsBuilder::new(_fbb);
    builder.add_dilation_h_factor(args.dilation_h_factor);
    builder.add_dilation_w_factor(args.dilation_w_factor);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }


  #[inline]
  pub fn padding(&self) -> Padding {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Padding>(Conv2DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()}
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv2DOptions::VT_STRIDE_W, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv2DOptions::VT_STRIDE_H, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn dilation_w_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv2DOptions::VT_DILATION_W_FACTOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn dilation_h_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv2DOptions::VT_DILATION_H_FACTOR, Some(1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Conv2DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
     .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct Conv2DOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub fused_activation_function: ActivationFunctionType,
    pub dilation_w_factor: i32,
    pub dilation_h_factor: i32,
}
impl<'a> Default for Conv2DOptionsArgs {
  #[inline]
  fn default() -> Self {
    Conv2DOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}

pub struct Conv2DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Conv2DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(Conv2DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  #[inline]
  pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Conv2DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Conv2DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Conv2DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Conv2DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Conv2DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("dilation_w_factor", &self.dilation_w_factor());
      ds.field("dilation_h_factor", &self.dilation_h_factor());
      ds.finish()
  }
}
pub enum Conv3DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Conv3DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Conv3DOptions<'a> {
  type Inner = Conv3DOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Conv3DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_D: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 8;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 10;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 12;
  pub const VT_DILATION_D_FACTOR: flatbuffers::VOffsetT = 14;
  pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 16;
  pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Conv3DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Conv3DOptionsArgs
  ) -> flatbuffers::WIPOffset<Conv3DOptions<'bldr>> {
    let mut builder = Conv3DOptionsBuilder::new(_fbb);
    builder.add_dilation_h_factor(args.dilation_h_factor);
    builder.add_dilation_w_factor(args.dilation_w_factor);
    builder.add_dilation_d_factor(args.dilation_d_factor);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_stride_d(args.stride_d);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }


  #[inline]
  pub fn padding(&self) -> Padding {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Padding>(Conv3DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()}
  }
  #[inline]
  pub fn stride_d(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv3DOptions::VT_STRIDE_D, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv3DOptions::VT_STRIDE_W, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv3DOptions::VT_STRIDE_H, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn dilation_d_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv3DOptions::VT_DILATION_D_FACTOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn dilation_w_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv3DOptions::VT_DILATION_W_FACTOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn dilation_h_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conv3DOptions::VT_DILATION_H_FACTOR, Some(1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Conv3DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_d", Self::VT_STRIDE_D, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<i32>("dilation_d_factor", Self::VT_DILATION_D_FACTOR, false)?
     .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
     .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct Conv3DOptionsArgs {
    pub padding: Padding,
    pub stride_d: i32,
    pub stride_w: i32,
    pub stride_h: i32,
    pub fused_activation_function: ActivationFunctionType,
    pub dilation_d_factor: i32,
    pub dilation_w_factor: i32,
    pub dilation_h_factor: i32,
}
impl<'a> Default for Conv3DOptionsArgs {
  #[inline]
  fn default() -> Self {
    Conv3DOptionsArgs {
      padding: Padding::SAME,
      stride_d: 0,
      stride_w: 0,
      stride_h: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_d_factor: 1,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}

pub struct Conv3DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Conv3DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(Conv3DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_d(&mut self, stride_d: i32) {
    self.fbb_.push_slot::<i32>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_dilation_d_factor(&mut self, dilation_d_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
  }
  #[inline]
  pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  #[inline]
  pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Conv3DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Conv3DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Conv3DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Conv3DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Conv3DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_d", &self.stride_d());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("dilation_d_factor", &self.dilation_d_factor());
      ds.field("dilation_w_factor", &self.dilation_w_factor());
      ds.field("dilation_h_factor", &self.dilation_h_factor());
      ds.finish()
  }
}
pub enum Pool2DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Pool2DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pool2DOptions<'a> {
  type Inner = Pool2DOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Pool2DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_FILTER_WIDTH: flatbuffers::VOffsetT = 10;
  pub const VT_FILTER_HEIGHT: flatbuffers::VOffsetT = 12;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Pool2DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Pool2DOptionsArgs
  ) -> flatbuffers::WIPOffset<Pool2DOptions<'bldr>> {
    let mut builder = Pool2DOptionsBuilder::new(_fbb);
    builder.add_filter_height(args.filter_height);
    builder.add_filter_width(args.filter_width);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }


  #[inline]
  pub fn padding(&self) -> Padding {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Padding>(Pool2DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()}
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Pool2DOptions::VT_STRIDE_W, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Pool2DOptions::VT_STRIDE_H, Some(0)).unwrap()}
  }
  #[inline]
  pub fn filter_width(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Pool2DOptions::VT_FILTER_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn filter_height(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Pool2DOptions::VT_FILTER_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Pool2DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<i32>("filter_width", Self::VT_FILTER_WIDTH, false)?
     .visit_field::<i32>("filter_height", Self::VT_FILTER_HEIGHT, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct Pool2DOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub filter_width: i32,
    pub filter_height: i32,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for Pool2DOptionsArgs {
  #[inline]
  fn default() -> Self {
    Pool2DOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      filter_width: 0,
      filter_height: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct Pool2DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Pool2DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(Pool2DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_filter_width(&mut self, filter_width: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  #[inline]
  pub fn add_filter_height(&mut self, filter_height: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Pool2DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Pool2DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pool2DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Pool2DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Pool2DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("filter_width", &self.filter_width());
      ds.field("filter_height", &self.filter_height());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
pub enum DepthwiseConv2DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DepthwiseConv2DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DepthwiseConv2DOptions<'a> {
  type Inner = DepthwiseConv2DOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DepthwiseConv2DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_DEPTH_MULTIPLIER: flatbuffers::VOffsetT = 10;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 12;
  pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 14;
  pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DepthwiseConv2DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DepthwiseConv2DOptionsArgs
  ) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'bldr>> {
    let mut builder = DepthwiseConv2DOptionsBuilder::new(_fbb);
    builder.add_dilation_h_factor(args.dilation_h_factor);
    builder.add_dilation_w_factor(args.dilation_w_factor);
    builder.add_depth_multiplier(args.depth_multiplier);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }


  #[inline]
  pub fn padding(&self) -> Padding {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Padding>(DepthwiseConv2DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()}
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DepthwiseConv2DOptions::VT_STRIDE_W, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DepthwiseConv2DOptions::VT_STRIDE_H, Some(0)).unwrap()}
  }
  #[inline]
  pub fn depth_multiplier(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn dilation_w_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn dilation_h_factor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, Some(1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DepthwiseConv2DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<i32>("depth_multiplier", Self::VT_DEPTH_MULTIPLIER, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
     .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct DepthwiseConv2DOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub depth_multiplier: i32,
    pub fused_activation_function: ActivationFunctionType,
    pub dilation_w_factor: i32,
    pub dilation_h_factor: i32,
}
impl<'a> Default for DepthwiseConv2DOptionsArgs {
  #[inline]
  fn default() -> Self {
    DepthwiseConv2DOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      depth_multiplier: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}

pub struct DepthwiseConv2DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DepthwiseConv2DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(DepthwiseConv2DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_depth_multiplier(&mut self, depth_multiplier: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  #[inline]
  pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DepthwiseConv2DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DepthwiseConv2DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DepthwiseConv2DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DepthwiseConv2DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("depth_multiplier", &self.depth_multiplier());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("dilation_w_factor", &self.dilation_w_factor());
      ds.field("dilation_h_factor", &self.dilation_h_factor());
      ds.finish()
  }
}
pub enum ConcatEmbeddingsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatEmbeddingsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatEmbeddingsOptions<'a> {
  type Inner = ConcatEmbeddingsOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConcatEmbeddingsOptions<'a> {
  pub const VT_NUM_CHANNELS: flatbuffers::VOffsetT = 4;
  pub const VT_NUM_COLUMNS_PER_CHANNEL: flatbuffers::VOffsetT = 6;
  pub const VT_EMBEDDING_DIM_PER_CHANNEL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConcatEmbeddingsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConcatEmbeddingsOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'bldr>> {
    let mut builder = ConcatEmbeddingsOptionsBuilder::new(_fbb);
    if let Some(x) = args.embedding_dim_per_channel { builder.add_embedding_dim_per_channel(x); }
    if let Some(x) = args.num_columns_per_channel { builder.add_num_columns_per_channel(x); }
    builder.add_num_channels(args.num_channels);
    builder.finish()
  }


  #[inline]
  pub fn num_channels(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num_columns_per_channel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, None)}
  }
  #[inline]
  pub fn embedding_dim_per_channel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, None)}
  }
}

impl flatbuffers::Verifiable for ConcatEmbeddingsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_channels", Self::VT_NUM_CHANNELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("num_columns_per_channel", Self::VT_NUM_COLUMNS_PER_CHANNEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("embedding_dim_per_channel", Self::VT_EMBEDDING_DIM_PER_CHANNEL, false)?
     .finish();
    Ok(())
  }
}
pub struct ConcatEmbeddingsOptionsArgs<'a> {
    pub num_channels: i32,
    pub num_columns_per_channel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub embedding_dim_per_channel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ConcatEmbeddingsOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConcatEmbeddingsOptionsArgs {
      num_channels: 0,
      num_columns_per_channel: None,
      embedding_dim_per_channel: None,
    }
  }
}

pub struct ConcatEmbeddingsOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatEmbeddingsOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_channels(&mut self, num_channels: i32) {
    self.fbb_.push_slot::<i32>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  #[inline]
  pub fn add_num_columns_per_channel(&mut self, num_columns_per_channel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  #[inline]
  pub fn add_embedding_dim_per_channel(&mut self, embedding_dim_per_channel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatEmbeddingsOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConcatEmbeddingsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConcatEmbeddingsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConcatEmbeddingsOptions");
      ds.field("num_channels", &self.num_channels());
      ds.field("num_columns_per_channel", &self.num_columns_per_channel());
      ds.field("embedding_dim_per_channel", &self.embedding_dim_per_channel());
      ds.finish()
  }
}
pub enum LSHProjectionOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LSHProjectionOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LSHProjectionOptions<'a> {
  type Inner = LSHProjectionOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LSHProjectionOptions<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LSHProjectionOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LSHProjectionOptionsArgs
  ) -> flatbuffers::WIPOffset<LSHProjectionOptions<'bldr>> {
    let mut builder = LSHProjectionOptionsBuilder::new(_fbb);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> LSHProjectionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LSHProjectionType>(LSHProjectionOptions::VT_TYPE_, Some(LSHProjectionType::UNKNOWN)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LSHProjectionOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<LSHProjectionType>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct LSHProjectionOptionsArgs {
    pub type_: LSHProjectionType,
}
impl<'a> Default for LSHProjectionOptionsArgs {
  #[inline]
  fn default() -> Self {
    LSHProjectionOptionsArgs {
      type_: LSHProjectionType::UNKNOWN,
    }
  }
}

pub struct LSHProjectionOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LSHProjectionOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: LSHProjectionType) {
    self.fbb_.push_slot::<LSHProjectionType>(LSHProjectionOptions::VT_TYPE_, type_, LSHProjectionType::UNKNOWN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LSHProjectionOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LSHProjectionOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LSHProjectionOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LSHProjectionOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LSHProjectionOptions");
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum SVDFOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SVDFOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SVDFOptions<'a> {
  type Inner = SVDFOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SVDFOptions<'a> {
  pub const VT_RANK: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SVDFOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SVDFOptionsArgs
  ) -> flatbuffers::WIPOffset<SVDFOptions<'bldr>> {
    let mut builder = SVDFOptionsBuilder::new(_fbb);
    builder.add_rank(args.rank);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn rank(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SVDFOptions::VT_RANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SVDFOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("rank", Self::VT_RANK, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct SVDFOptionsArgs {
    pub rank: i32,
    pub fused_activation_function: ActivationFunctionType,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for SVDFOptionsArgs {
  #[inline]
  fn default() -> Self {
    SVDFOptionsArgs {
      rank: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct SVDFOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SVDFOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_rank(&mut self, rank: i32) {
    self.fbb_.push_slot::<i32>(SVDFOptions::VT_RANK, rank, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SVDFOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SVDFOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SVDFOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SVDFOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SVDFOptions");
      ds.field("rank", &self.rank());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum RNNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RNNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RNNOptions<'a> {
  type Inner = RNNOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RNNOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RNNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RNNOptionsArgs
  ) -> flatbuffers::WIPOffset<RNNOptions<'bldr>> {
    let mut builder = RNNOptionsBuilder::new(_fbb);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RNNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct RNNOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for RNNOptionsArgs {
  #[inline]
  fn default() -> Self {
    RNNOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct RNNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RNNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RNNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RNNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RNNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RNNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RNNOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum SequenceRNNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SequenceRNNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SequenceRNNOptions<'a> {
  type Inner = SequenceRNNOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SequenceRNNOptions<'a> {
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SequenceRNNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SequenceRNNOptionsArgs
  ) -> flatbuffers::WIPOffset<SequenceRNNOptions<'bldr>> {
    let mut builder = SequenceRNNOptionsBuilder::new(_fbb);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_time_major(args.time_major);
    builder.finish()
  }


  #[inline]
  pub fn time_major(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SequenceRNNOptions::VT_TIME_MAJOR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SequenceRNNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct SequenceRNNOptionsArgs {
    pub time_major: bool,
    pub fused_activation_function: ActivationFunctionType,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for SequenceRNNOptionsArgs {
  #[inline]
  fn default() -> Self {
    SequenceRNNOptionsArgs {
      time_major: false,
      fused_activation_function: ActivationFunctionType::NONE,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct SequenceRNNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SequenceRNNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(SequenceRNNOptions::VT_TIME_MAJOR, time_major, false);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SequenceRNNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SequenceRNNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SequenceRNNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SequenceRNNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SequenceRNNOptions");
      ds.field("time_major", &self.time_major());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum BidirectionalSequenceRNNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BidirectionalSequenceRNNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BidirectionalSequenceRNNOptions<'a> {
  type Inner = BidirectionalSequenceRNNOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BidirectionalSequenceRNNOptions<'a> {
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
  pub const VT_MERGE_OUTPUTS: flatbuffers::VOffsetT = 8;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BidirectionalSequenceRNNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BidirectionalSequenceRNNOptionsArgs
  ) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'bldr>> {
    let mut builder = BidirectionalSequenceRNNOptionsBuilder::new(_fbb);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_merge_outputs(args.merge_outputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_time_major(args.time_major);
    builder.finish()
  }


  #[inline]
  pub fn time_major(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn merge_outputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BidirectionalSequenceRNNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("merge_outputs", Self::VT_MERGE_OUTPUTS, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BidirectionalSequenceRNNOptionsArgs {
    pub time_major: bool,
    pub fused_activation_function: ActivationFunctionType,
    pub merge_outputs: bool,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for BidirectionalSequenceRNNOptionsArgs {
  #[inline]
  fn default() -> Self {
    BidirectionalSequenceRNNOptionsArgs {
      time_major: false,
      fused_activation_function: ActivationFunctionType::NONE,
      merge_outputs: false,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct BidirectionalSequenceRNNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BidirectionalSequenceRNNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, time_major, false);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_merge_outputs(&mut self, merge_outputs: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, merge_outputs, false);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BidirectionalSequenceRNNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BidirectionalSequenceRNNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BidirectionalSequenceRNNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BidirectionalSequenceRNNOptions");
      ds.field("time_major", &self.time_major());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("merge_outputs", &self.merge_outputs());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum FullyConnectedOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FullyConnectedOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FullyConnectedOptions<'a> {
  type Inner = FullyConnectedOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FullyConnectedOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHTS_FORMAT: flatbuffers::VOffsetT = 6;
  pub const VT_KEEP_NUM_DIMS: flatbuffers::VOffsetT = 8;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FullyConnectedOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FullyConnectedOptionsArgs
  ) -> flatbuffers::WIPOffset<FullyConnectedOptions<'bldr>> {
    let mut builder = FullyConnectedOptionsBuilder::new(_fbb);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_keep_num_dims(args.keep_num_dims);
    builder.add_weights_format(args.weights_format);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn weights_format(&self) -> FullyConnectedOptionsWeightsFormat {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FullyConnectedOptionsWeightsFormat>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, Some(FullyConnectedOptionsWeightsFormat::DEFAULT)).unwrap()}
  }
  #[inline]
  pub fn keep_num_dims(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FullyConnectedOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<FullyConnectedOptionsWeightsFormat>("weights_format", Self::VT_WEIGHTS_FORMAT, false)?
     .visit_field::<bool>("keep_num_dims", Self::VT_KEEP_NUM_DIMS, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct FullyConnectedOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub weights_format: FullyConnectedOptionsWeightsFormat,
    pub keep_num_dims: bool,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for FullyConnectedOptionsArgs {
  #[inline]
  fn default() -> Self {
    FullyConnectedOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      weights_format: FullyConnectedOptionsWeightsFormat::DEFAULT,
      keep_num_dims: false,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct FullyConnectedOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FullyConnectedOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_weights_format(&mut self, weights_format: FullyConnectedOptionsWeightsFormat) {
    self.fbb_.push_slot::<FullyConnectedOptionsWeightsFormat>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, weights_format, FullyConnectedOptionsWeightsFormat::DEFAULT);
  }
  #[inline]
  pub fn add_keep_num_dims(&mut self, keep_num_dims: bool) {
    self.fbb_.push_slot::<bool>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, keep_num_dims, false);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FullyConnectedOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FullyConnectedOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FullyConnectedOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FullyConnectedOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FullyConnectedOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("weights_format", &self.weights_format());
      ds.field("keep_num_dims", &self.keep_num_dims());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum SoftmaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SoftmaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SoftmaxOptions<'a> {
  type Inner = SoftmaxOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SoftmaxOptions<'a> {
  pub const VT_BETA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SoftmaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SoftmaxOptionsArgs
  ) -> flatbuffers::WIPOffset<SoftmaxOptions<'bldr>> {
    let mut builder = SoftmaxOptionsBuilder::new(_fbb);
    builder.add_beta(args.beta);
    builder.finish()
  }


  #[inline]
  pub fn beta(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SoftmaxOptions::VT_BETA, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SoftmaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("beta", Self::VT_BETA, false)?
     .finish();
    Ok(())
  }
}
pub struct SoftmaxOptionsArgs {
    pub beta: f32,
}
impl<'a> Default for SoftmaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    SoftmaxOptionsArgs {
      beta: 0.0,
    }
  }
}

pub struct SoftmaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SoftmaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_beta(&mut self, beta: f32) {
    self.fbb_.push_slot::<f32>(SoftmaxOptions::VT_BETA, beta, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SoftmaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SoftmaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SoftmaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SoftmaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SoftmaxOptions");
      ds.field("beta", &self.beta());
      ds.finish()
  }
}
pub enum ConcatenationOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatenationOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatenationOptions<'a> {
  type Inner = ConcatenationOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConcatenationOptions<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConcatenationOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConcatenationOptionsArgs
  ) -> flatbuffers::WIPOffset<ConcatenationOptions<'bldr>> {
    let mut builder = ConcatenationOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn axis(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConcatenationOptions::VT_AXIS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ConcatenationOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct ConcatenationOptionsArgs {
    pub axis: i32,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for ConcatenationOptionsArgs {
  #[inline]
  fn default() -> Self {
    ConcatenationOptionsArgs {
      axis: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct ConcatenationOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatenationOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatenationOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConcatenationOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConcatenationOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConcatenationOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConcatenationOptions");
      ds.field("axis", &self.axis());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
pub enum AddOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AddOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddOptions<'a> {
  type Inner = AddOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AddOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_POT_SCALE_INT16: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AddOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddOptionsArgs
  ) -> flatbuffers::WIPOffset<AddOptions<'bldr>> {
    let mut builder = AddOptionsBuilder::new(_fbb);
    builder.add_pot_scale_int16(args.pot_scale_int16);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn pot_scale_int16(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AddOptions::VT_POT_SCALE_INT16, Some(true)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AddOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("pot_scale_int16", Self::VT_POT_SCALE_INT16, false)?
     .finish();
    Ok(())
  }
}
pub struct AddOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub pot_scale_int16: bool,
}
impl<'a> Default for AddOptionsArgs {
  #[inline]
  fn default() -> Self {
    AddOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      pot_scale_int16: true,
    }
  }
}

pub struct AddOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_pot_scale_int16(&mut self, pot_scale_int16: bool) {
    self.fbb_.push_slot::<bool>(AddOptions::VT_POT_SCALE_INT16, pot_scale_int16, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AddOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AddOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("pot_scale_int16", &self.pot_scale_int16());
      ds.finish()
  }
}
pub enum MulOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MulOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MulOptions<'a> {
  type Inner = MulOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MulOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MulOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MulOptionsArgs
  ) -> flatbuffers::WIPOffset<MulOptions<'bldr>> {
    let mut builder = MulOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MulOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct MulOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for MulOptionsArgs {
  #[inline]
  fn default() -> Self {
    MulOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct MulOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MulOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MulOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MulOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MulOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MulOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MulOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
pub enum L2NormOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct L2NormOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for L2NormOptions<'a> {
  type Inner = L2NormOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> L2NormOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    L2NormOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args L2NormOptionsArgs
  ) -> flatbuffers::WIPOffset<L2NormOptions<'bldr>> {
    let mut builder = L2NormOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for L2NormOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct L2NormOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for L2NormOptionsArgs {
  #[inline]
  fn default() -> Self {
    L2NormOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct L2NormOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> L2NormOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> L2NormOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    L2NormOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<L2NormOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for L2NormOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("L2NormOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
pub enum LocalResponseNormalizationOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LocalResponseNormalizationOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LocalResponseNormalizationOptions<'a> {
  type Inner = LocalResponseNormalizationOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LocalResponseNormalizationOptions<'a> {
  pub const VT_RADIUS: flatbuffers::VOffsetT = 4;
  pub const VT_BIAS: flatbuffers::VOffsetT = 6;
  pub const VT_ALPHA: flatbuffers::VOffsetT = 8;
  pub const VT_BETA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LocalResponseNormalizationOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LocalResponseNormalizationOptionsArgs
  ) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'bldr>> {
    let mut builder = LocalResponseNormalizationOptionsBuilder::new(_fbb);
    builder.add_beta(args.beta);
    builder.add_alpha(args.alpha);
    builder.add_bias(args.bias);
    builder.add_radius(args.radius);
    builder.finish()
  }


  #[inline]
  pub fn radius(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LocalResponseNormalizationOptions::VT_RADIUS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bias(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LocalResponseNormalizationOptions::VT_BIAS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn alpha(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LocalResponseNormalizationOptions::VT_ALPHA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn beta(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LocalResponseNormalizationOptions::VT_BETA, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LocalResponseNormalizationOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("radius", Self::VT_RADIUS, false)?
     .visit_field::<f32>("bias", Self::VT_BIAS, false)?
     .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
     .visit_field::<f32>("beta", Self::VT_BETA, false)?
     .finish();
    Ok(())
  }
}
pub struct LocalResponseNormalizationOptionsArgs {
    pub radius: i32,
    pub bias: f32,
    pub alpha: f32,
    pub beta: f32,
}
impl<'a> Default for LocalResponseNormalizationOptionsArgs {
  #[inline]
  fn default() -> Self {
    LocalResponseNormalizationOptionsArgs {
      radius: 0,
      bias: 0.0,
      alpha: 0.0,
      beta: 0.0,
    }
  }
}

pub struct LocalResponseNormalizationOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LocalResponseNormalizationOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_radius(&mut self, radius: i32) {
    self.fbb_.push_slot::<i32>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  #[inline]
  pub fn add_bias(&mut self, bias: f32) {
    self.fbb_.push_slot::<f32>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0);
  }
  #[inline]
  pub fn add_alpha(&mut self, alpha: f32) {
    self.fbb_.push_slot::<f32>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0);
  }
  #[inline]
  pub fn add_beta(&mut self, beta: f32) {
    self.fbb_.push_slot::<f32>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LocalResponseNormalizationOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LocalResponseNormalizationOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LocalResponseNormalizationOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LocalResponseNormalizationOptions");
      ds.field("radius", &self.radius());
      ds.field("bias", &self.bias());
      ds.field("alpha", &self.alpha());
      ds.field("beta", &self.beta());
      ds.finish()
  }
}
pub enum LSTMOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LSTMOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LSTMOptions<'a> {
  type Inner = LSTMOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LSTMOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
  pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_KERNEL_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LSTMOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LSTMOptionsArgs
  ) -> flatbuffers::WIPOffset<LSTMOptions<'bldr>> {
    let mut builder = LSTMOptionsBuilder::new(_fbb);
    builder.add_proj_clip(args.proj_clip);
    builder.add_cell_clip(args.cell_clip);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_kernel_type(args.kernel_type);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn cell_clip(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LSTMOptions::VT_CELL_CLIP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn proj_clip(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LSTMOptions::VT_PROJ_CLIP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn kernel_type(&self) -> LSTMKernelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LSTMKernelType>(LSTMOptions::VT_KERNEL_TYPE, Some(LSTMKernelType::FULL)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LSTMOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
     .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
     .visit_field::<LSTMKernelType>("kernel_type", Self::VT_KERNEL_TYPE, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct LSTMOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub kernel_type: LSTMKernelType,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for LSTMOptionsArgs {
  #[inline]
  fn default() -> Self {
    LSTMOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      kernel_type: LSTMKernelType::FULL,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct LSTMOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LSTMOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_cell_clip(&mut self, cell_clip: f32) {
    self.fbb_.push_slot::<f32>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
  }
  #[inline]
  pub fn add_proj_clip(&mut self, proj_clip: f32) {
    self.fbb_.push_slot::<f32>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
  }
  #[inline]
  pub fn add_kernel_type(&mut self, kernel_type: LSTMKernelType) {
    self.fbb_.push_slot::<LSTMKernelType>(LSTMOptions::VT_KERNEL_TYPE, kernel_type, LSTMKernelType::FULL);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LSTMOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LSTMOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LSTMOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LSTMOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LSTMOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("cell_clip", &self.cell_clip());
      ds.field("proj_clip", &self.proj_clip());
      ds.field("kernel_type", &self.kernel_type());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum UnidirectionalSequenceLSTMOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnidirectionalSequenceLSTMOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnidirectionalSequenceLSTMOptions<'a> {
  type Inner = UnidirectionalSequenceLSTMOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnidirectionalSequenceLSTMOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
  pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 10;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 12;
  pub const VT_DIAGONAL_RECURRENT_TENSORS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnidirectionalSequenceLSTMOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnidirectionalSequenceLSTMOptionsArgs
  ) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'bldr>> {
    let mut builder = UnidirectionalSequenceLSTMOptionsBuilder::new(_fbb);
    builder.add_proj_clip(args.proj_clip);
    builder.add_cell_clip(args.cell_clip);
    builder.add_diagonal_recurrent_tensors(args.diagonal_recurrent_tensors);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_time_major(args.time_major);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn cell_clip(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn proj_clip(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn time_major(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn diagonal_recurrent_tensors(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UnidirectionalSequenceLSTMOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
     .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .visit_field::<bool>("diagonal_recurrent_tensors", Self::VT_DIAGONAL_RECURRENT_TENSORS, false)?
     .finish();
    Ok(())
  }
}
pub struct UnidirectionalSequenceLSTMOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub time_major: bool,
    pub asymmetric_quantize_inputs: bool,
    pub diagonal_recurrent_tensors: bool,
}
impl<'a> Default for UnidirectionalSequenceLSTMOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnidirectionalSequenceLSTMOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      time_major: false,
      asymmetric_quantize_inputs: false,
      diagonal_recurrent_tensors: false,
    }
  }
}

pub struct UnidirectionalSequenceLSTMOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_cell_clip(&mut self, cell_clip: f32) {
    self.fbb_.push_slot::<f32>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
  }
  #[inline]
  pub fn add_proj_clip(&mut self, proj_clip: f32) {
    self.fbb_.push_slot::<f32>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
  }
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, time_major, false);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn add_diagonal_recurrent_tensors(&mut self, diagonal_recurrent_tensors: bool) {
    self.fbb_.push_slot::<bool>(UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS, diagonal_recurrent_tensors, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnidirectionalSequenceLSTMOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnidirectionalSequenceLSTMOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnidirectionalSequenceLSTMOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("cell_clip", &self.cell_clip());
      ds.field("proj_clip", &self.proj_clip());
      ds.field("time_major", &self.time_major());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.field("diagonal_recurrent_tensors", &self.diagonal_recurrent_tensors());
      ds.finish()
  }
}
pub enum BidirectionalSequenceLSTMOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BidirectionalSequenceLSTMOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BidirectionalSequenceLSTMOptions<'a> {
  type Inner = BidirectionalSequenceLSTMOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BidirectionalSequenceLSTMOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
  pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_MERGE_OUTPUTS: flatbuffers::VOffsetT = 10;
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 12;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BidirectionalSequenceLSTMOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BidirectionalSequenceLSTMOptionsArgs
  ) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'bldr>> {
    let mut builder = BidirectionalSequenceLSTMOptionsBuilder::new(_fbb);
    builder.add_proj_clip(args.proj_clip);
    builder.add_cell_clip(args.cell_clip);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_time_major(args.time_major);
    builder.add_merge_outputs(args.merge_outputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn cell_clip(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn proj_clip(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn merge_outputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn time_major(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, Some(true)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BidirectionalSequenceLSTMOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
     .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
     .visit_field::<bool>("merge_outputs", Self::VT_MERGE_OUTPUTS, false)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BidirectionalSequenceLSTMOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub merge_outputs: bool,
    pub time_major: bool,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for BidirectionalSequenceLSTMOptionsArgs {
  #[inline]
  fn default() -> Self {
    BidirectionalSequenceLSTMOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      merge_outputs: false,
      time_major: true,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct BidirectionalSequenceLSTMOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_cell_clip(&mut self, cell_clip: f32) {
    self.fbb_.push_slot::<f32>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
  }
  #[inline]
  pub fn add_proj_clip(&mut self, proj_clip: f32) {
    self.fbb_.push_slot::<f32>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
  }
  #[inline]
  pub fn add_merge_outputs(&mut self, merge_outputs: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, merge_outputs, false);
  }
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, time_major, true);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BidirectionalSequenceLSTMOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BidirectionalSequenceLSTMOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BidirectionalSequenceLSTMOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("cell_clip", &self.cell_clip());
      ds.field("proj_clip", &self.proj_clip());
      ds.field("merge_outputs", &self.merge_outputs());
      ds.field("time_major", &self.time_major());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum ResizeBilinearOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeBilinearOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeBilinearOptions<'a> {
  type Inner = ResizeBilinearOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ResizeBilinearOptions<'a> {
  pub const VT_ALIGN_CORNERS: flatbuffers::VOffsetT = 8;
  pub const VT_HALF_PIXEL_CENTERS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResizeBilinearOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResizeBilinearOptionsArgs
  ) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'bldr>> {
    let mut builder = ResizeBilinearOptionsBuilder::new(_fbb);
    builder.add_half_pixel_centers(args.half_pixel_centers);
    builder.add_align_corners(args.align_corners);
    builder.finish()
  }


  #[inline]
  pub fn align_corners(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ResizeBilinearOptions::VT_ALIGN_CORNERS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn half_pixel_centers(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ResizeBilinearOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("align_corners", Self::VT_ALIGN_CORNERS, false)?
     .visit_field::<bool>("half_pixel_centers", Self::VT_HALF_PIXEL_CENTERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ResizeBilinearOptionsArgs {
    pub align_corners: bool,
    pub half_pixel_centers: bool,
}
impl<'a> Default for ResizeBilinearOptionsArgs {
  #[inline]
  fn default() -> Self {
    ResizeBilinearOptionsArgs {
      align_corners: false,
      half_pixel_centers: false,
    }
  }
}

pub struct ResizeBilinearOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResizeBilinearOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_align_corners(&mut self, align_corners: bool) {
    self.fbb_.push_slot::<bool>(ResizeBilinearOptions::VT_ALIGN_CORNERS, align_corners, false);
  }
  #[inline]
  pub fn add_half_pixel_centers(&mut self, half_pixel_centers: bool) {
    self.fbb_.push_slot::<bool>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, half_pixel_centers, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResizeBilinearOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResizeBilinearOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResizeBilinearOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResizeBilinearOptions");
      ds.field("align_corners", &self.align_corners());
      ds.field("half_pixel_centers", &self.half_pixel_centers());
      ds.finish()
  }
}
pub enum ResizeNearestNeighborOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeNearestNeighborOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeNearestNeighborOptions<'a> {
  type Inner = ResizeNearestNeighborOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ResizeNearestNeighborOptions<'a> {
  pub const VT_ALIGN_CORNERS: flatbuffers::VOffsetT = 4;
  pub const VT_HALF_PIXEL_CENTERS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResizeNearestNeighborOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResizeNearestNeighborOptionsArgs
  ) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'bldr>> {
    let mut builder = ResizeNearestNeighborOptionsBuilder::new(_fbb);
    builder.add_half_pixel_centers(args.half_pixel_centers);
    builder.add_align_corners(args.align_corners);
    builder.finish()
  }


  #[inline]
  pub fn align_corners(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn half_pixel_centers(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ResizeNearestNeighborOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("align_corners", Self::VT_ALIGN_CORNERS, false)?
     .visit_field::<bool>("half_pixel_centers", Self::VT_HALF_PIXEL_CENTERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ResizeNearestNeighborOptionsArgs {
    pub align_corners: bool,
    pub half_pixel_centers: bool,
}
impl<'a> Default for ResizeNearestNeighborOptionsArgs {
  #[inline]
  fn default() -> Self {
    ResizeNearestNeighborOptionsArgs {
      align_corners: false,
      half_pixel_centers: false,
    }
  }
}

pub struct ResizeNearestNeighborOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResizeNearestNeighborOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_align_corners(&mut self, align_corners: bool) {
    self.fbb_.push_slot::<bool>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, align_corners, false);
  }
  #[inline]
  pub fn add_half_pixel_centers(&mut self, half_pixel_centers: bool) {
    self.fbb_.push_slot::<bool>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS, half_pixel_centers, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResizeNearestNeighborOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResizeNearestNeighborOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResizeNearestNeighborOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResizeNearestNeighborOptions");
      ds.field("align_corners", &self.align_corners());
      ds.field("half_pixel_centers", &self.half_pixel_centers());
      ds.finish()
  }
}
pub enum CallOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CallOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CallOptions<'a> {
  type Inner = CallOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CallOptions<'a> {
  pub const VT_SUBGRAPH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CallOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CallOptionsArgs
  ) -> flatbuffers::WIPOffset<CallOptions<'bldr>> {
    let mut builder = CallOptionsBuilder::new(_fbb);
    builder.add_subgraph(args.subgraph);
    builder.finish()
  }


  #[inline]
  pub fn subgraph(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CallOptions::VT_SUBGRAPH, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CallOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("subgraph", Self::VT_SUBGRAPH, false)?
     .finish();
    Ok(())
  }
}
pub struct CallOptionsArgs {
    pub subgraph: u32,
}
impl<'a> Default for CallOptionsArgs {
  #[inline]
  fn default() -> Self {
    CallOptionsArgs {
      subgraph: 0,
    }
  }
}

pub struct CallOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_subgraph(&mut self, subgraph: u32) {
    self.fbb_.push_slot::<u32>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CallOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CallOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CallOptions");
      ds.field("subgraph", &self.subgraph());
      ds.finish()
  }
}
pub enum PadOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PadOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PadOptions<'a> {
  type Inner = PadOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PadOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PadOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PadOptionsArgs
  ) -> flatbuffers::WIPOffset<PadOptions<'bldr>> {
    let mut builder = PadOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for PadOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PadOptionsArgs {
}
impl<'a> Default for PadOptionsArgs {
  #[inline]
  fn default() -> Self {
    PadOptionsArgs {
    }
  }
}

pub struct PadOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PadOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PadOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PadOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PadOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PadOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PadOptions");
      ds.finish()
  }
}
pub enum PadV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PadV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PadV2Options<'a> {
  type Inner = PadV2Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PadV2Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PadV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PadV2OptionsArgs
  ) -> flatbuffers::WIPOffset<PadV2Options<'bldr>> {
    let mut builder = PadV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for PadV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PadV2OptionsArgs {
}
impl<'a> Default for PadV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    PadV2OptionsArgs {
    }
  }
}

pub struct PadV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PadV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PadV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PadV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PadV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PadV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PadV2Options");
      ds.finish()
  }
}
pub enum ReshapeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReshapeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReshapeOptions<'a> {
  type Inner = ReshapeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReshapeOptions<'a> {
  pub const VT_NEW_SHAPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReshapeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReshapeOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<ReshapeOptions<'bldr>> {
    let mut builder = ReshapeOptionsBuilder::new(_fbb);
    if let Some(x) = args.new_shape { builder.add_new_shape(x); }
    builder.finish()
  }


  #[inline]
  pub fn new_shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ReshapeOptions::VT_NEW_SHAPE, None)}
  }
}

impl flatbuffers::Verifiable for ReshapeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("new_shape", Self::VT_NEW_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ReshapeOptionsArgs<'a> {
    pub new_shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ReshapeOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReshapeOptionsArgs {
      new_shape: None,
    }
  }
}

pub struct ReshapeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReshapeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_new_shape(&mut self, new_shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReshapeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReshapeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReshapeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReshapeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReshapeOptions");
      ds.field("new_shape", &self.new_shape());
      ds.finish()
  }
}
pub enum SpaceToBatchNDOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpaceToBatchNDOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpaceToBatchNDOptions<'a> {
  type Inner = SpaceToBatchNDOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpaceToBatchNDOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpaceToBatchNDOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SpaceToBatchNDOptionsArgs
  ) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'bldr>> {
    let mut builder = SpaceToBatchNDOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SpaceToBatchNDOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SpaceToBatchNDOptionsArgs {
}
impl<'a> Default for SpaceToBatchNDOptionsArgs {
  #[inline]
  fn default() -> Self {
    SpaceToBatchNDOptionsArgs {
    }
  }
}

pub struct SpaceToBatchNDOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpaceToBatchNDOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpaceToBatchNDOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpaceToBatchNDOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpaceToBatchNDOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpaceToBatchNDOptions");
      ds.finish()
  }
}
pub enum BatchToSpaceNDOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BatchToSpaceNDOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchToSpaceNDOptions<'a> {
  type Inner = BatchToSpaceNDOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BatchToSpaceNDOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BatchToSpaceNDOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args BatchToSpaceNDOptionsArgs
  ) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'bldr>> {
    let mut builder = BatchToSpaceNDOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for BatchToSpaceNDOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct BatchToSpaceNDOptionsArgs {
}
impl<'a> Default for BatchToSpaceNDOptionsArgs {
  #[inline]
  fn default() -> Self {
    BatchToSpaceNDOptionsArgs {
    }
  }
}

pub struct BatchToSpaceNDOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BatchToSpaceNDOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BatchToSpaceNDOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BatchToSpaceNDOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BatchToSpaceNDOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BatchToSpaceNDOptions");
      ds.finish()
  }
}
pub enum SkipGramOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SkipGramOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SkipGramOptions<'a> {
  type Inner = SkipGramOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SkipGramOptions<'a> {
  pub const VT_NGRAM_SIZE: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_SKIP_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_INCLUDE_ALL_NGRAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SkipGramOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SkipGramOptionsArgs
  ) -> flatbuffers::WIPOffset<SkipGramOptions<'bldr>> {
    let mut builder = SkipGramOptionsBuilder::new(_fbb);
    builder.add_max_skip_size(args.max_skip_size);
    builder.add_ngram_size(args.ngram_size);
    builder.add_include_all_ngrams(args.include_all_ngrams);
    builder.finish()
  }


  #[inline]
  pub fn ngram_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SkipGramOptions::VT_NGRAM_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_skip_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SkipGramOptions::VT_MAX_SKIP_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn include_all_ngrams(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SkipGramOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("ngram_size", Self::VT_NGRAM_SIZE, false)?
     .visit_field::<i32>("max_skip_size", Self::VT_MAX_SKIP_SIZE, false)?
     .visit_field::<bool>("include_all_ngrams", Self::VT_INCLUDE_ALL_NGRAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SkipGramOptionsArgs {
    pub ngram_size: i32,
    pub max_skip_size: i32,
    pub include_all_ngrams: bool,
}
impl<'a> Default for SkipGramOptionsArgs {
  #[inline]
  fn default() -> Self {
    SkipGramOptionsArgs {
      ngram_size: 0,
      max_skip_size: 0,
      include_all_ngrams: false,
    }
  }
}

pub struct SkipGramOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SkipGramOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_ngram_size(&mut self, ngram_size: i32) {
    self.fbb_.push_slot::<i32>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  #[inline]
  pub fn add_max_skip_size(&mut self, max_skip_size: i32) {
    self.fbb_.push_slot::<i32>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  #[inline]
  pub fn add_include_all_ngrams(&mut self, include_all_ngrams: bool) {
    self.fbb_.push_slot::<bool>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, include_all_ngrams, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SkipGramOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SkipGramOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SkipGramOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SkipGramOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SkipGramOptions");
      ds.field("ngram_size", &self.ngram_size());
      ds.field("max_skip_size", &self.max_skip_size());
      ds.field("include_all_ngrams", &self.include_all_ngrams());
      ds.finish()
  }
}
pub enum SpaceToDepthOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpaceToDepthOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpaceToDepthOptions<'a> {
  type Inner = SpaceToDepthOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpaceToDepthOptions<'a> {
  pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpaceToDepthOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpaceToDepthOptionsArgs
  ) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'bldr>> {
    let mut builder = SpaceToDepthOptionsBuilder::new(_fbb);
    builder.add_block_size(args.block_size);
    builder.finish()
  }


  #[inline]
  pub fn block_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SpaceToDepthOptions::VT_BLOCK_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SpaceToDepthOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("block_size", Self::VT_BLOCK_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct SpaceToDepthOptionsArgs {
    pub block_size: i32,
}
impl<'a> Default for SpaceToDepthOptionsArgs {
  #[inline]
  fn default() -> Self {
    SpaceToDepthOptionsArgs {
      block_size: 0,
    }
  }
}

pub struct SpaceToDepthOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpaceToDepthOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_size(&mut self, block_size: i32) {
    self.fbb_.push_slot::<i32>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpaceToDepthOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpaceToDepthOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpaceToDepthOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpaceToDepthOptions");
      ds.field("block_size", &self.block_size());
      ds.finish()
  }
}
pub enum DepthToSpaceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DepthToSpaceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DepthToSpaceOptions<'a> {
  type Inner = DepthToSpaceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DepthToSpaceOptions<'a> {
  pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DepthToSpaceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DepthToSpaceOptionsArgs
  ) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'bldr>> {
    let mut builder = DepthToSpaceOptionsBuilder::new(_fbb);
    builder.add_block_size(args.block_size);
    builder.finish()
  }


  #[inline]
  pub fn block_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DepthToSpaceOptions::VT_BLOCK_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DepthToSpaceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("block_size", Self::VT_BLOCK_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DepthToSpaceOptionsArgs {
    pub block_size: i32,
}
impl<'a> Default for DepthToSpaceOptionsArgs {
  #[inline]
  fn default() -> Self {
    DepthToSpaceOptionsArgs {
      block_size: 0,
    }
  }
}

pub struct DepthToSpaceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DepthToSpaceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_size(&mut self, block_size: i32) {
    self.fbb_.push_slot::<i32>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DepthToSpaceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DepthToSpaceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DepthToSpaceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DepthToSpaceOptions");
      ds.field("block_size", &self.block_size());
      ds.finish()
  }
}
pub enum SubOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubOptions<'a> {
  type Inner = SubOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SubOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_POT_SCALE_INT16: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubOptionsArgs
  ) -> flatbuffers::WIPOffset<SubOptions<'bldr>> {
    let mut builder = SubOptionsBuilder::new(_fbb);
    builder.add_pot_scale_int16(args.pot_scale_int16);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
  #[inline]
  pub fn pot_scale_int16(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubOptions::VT_POT_SCALE_INT16, Some(true)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SubOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("pot_scale_int16", Self::VT_POT_SCALE_INT16, false)?
     .finish();
    Ok(())
  }
}
pub struct SubOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub pot_scale_int16: bool,
}
impl<'a> Default for SubOptionsArgs {
  #[inline]
  fn default() -> Self {
    SubOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      pot_scale_int16: true,
    }
  }
}

pub struct SubOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_pot_scale_int16(&mut self, pot_scale_int16: bool) {
    self.fbb_.push_slot::<bool>(SubOptions::VT_POT_SCALE_INT16, pot_scale_int16, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("pot_scale_int16", &self.pot_scale_int16());
      ds.finish()
  }
}
pub enum DivOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DivOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DivOptions<'a> {
  type Inner = DivOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DivOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DivOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DivOptionsArgs
  ) -> flatbuffers::WIPOffset<DivOptions<'bldr>> {
    let mut builder = DivOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }


  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DivOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct DivOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for DivOptionsArgs {
  #[inline]
  fn default() -> Self {
    DivOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct DivOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DivOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DivOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DivOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DivOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DivOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DivOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
pub enum TopKV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TopKV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TopKV2Options<'a> {
  type Inner = TopKV2Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TopKV2Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TopKV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TopKV2OptionsArgs
  ) -> flatbuffers::WIPOffset<TopKV2Options<'bldr>> {
    let mut builder = TopKV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for TopKV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TopKV2OptionsArgs {
}
impl<'a> Default for TopKV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    TopKV2OptionsArgs {
    }
  }
}

pub struct TopKV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TopKV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TopKV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TopKV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TopKV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TopKV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TopKV2Options");
      ds.finish()
  }
}
pub enum EmbeddingLookupSparseOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EmbeddingLookupSparseOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EmbeddingLookupSparseOptions<'a> {
  type Inner = EmbeddingLookupSparseOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EmbeddingLookupSparseOptions<'a> {
  pub const VT_COMBINER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EmbeddingLookupSparseOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EmbeddingLookupSparseOptionsArgs
  ) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'bldr>> {
    let mut builder = EmbeddingLookupSparseOptionsBuilder::new(_fbb);
    builder.add_combiner(args.combiner);
    builder.finish()
  }


  #[inline]
  pub fn combiner(&self) -> CombinerType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CombinerType>(EmbeddingLookupSparseOptions::VT_COMBINER, Some(CombinerType::SUM)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EmbeddingLookupSparseOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<CombinerType>("combiner", Self::VT_COMBINER, false)?
     .finish();
    Ok(())
  }
}
pub struct EmbeddingLookupSparseOptionsArgs {
    pub combiner: CombinerType,
}
impl<'a> Default for EmbeddingLookupSparseOptionsArgs {
  #[inline]
  fn default() -> Self {
    EmbeddingLookupSparseOptionsArgs {
      combiner: CombinerType::SUM,
    }
  }
}

pub struct EmbeddingLookupSparseOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EmbeddingLookupSparseOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_combiner(&mut self, combiner: CombinerType) {
    self.fbb_.push_slot::<CombinerType>(EmbeddingLookupSparseOptions::VT_COMBINER, combiner, CombinerType::SUM);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EmbeddingLookupSparseOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EmbeddingLookupSparseOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EmbeddingLookupSparseOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EmbeddingLookupSparseOptions");
      ds.field("combiner", &self.combiner());
      ds.finish()
  }
}
pub enum GatherOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherOptions<'a> {
  type Inner = GatherOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatherOptions<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;
  pub const VT_BATCH_DIMS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatherOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatherOptionsArgs
  ) -> flatbuffers::WIPOffset<GatherOptions<'bldr>> {
    let mut builder = GatherOptionsBuilder::new(_fbb);
    builder.add_batch_dims(args.batch_dims);
    builder.add_axis(args.axis);
    builder.finish()
  }


  #[inline]
  pub fn axis(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GatherOptions::VT_AXIS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn batch_dims(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GatherOptions::VT_BATCH_DIMS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GatherOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .visit_field::<i32>("batch_dims", Self::VT_BATCH_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct GatherOptionsArgs {
    pub axis: i32,
    pub batch_dims: i32,
}
impl<'a> Default for GatherOptionsArgs {
  #[inline]
  fn default() -> Self {
    GatherOptionsArgs {
      axis: 0,
      batch_dims: 0,
    }
  }
}

pub struct GatherOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatherOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(GatherOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn add_batch_dims(&mut self, batch_dims: i32) {
    self.fbb_.push_slot::<i32>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatherOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatherOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatherOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatherOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatherOptions");
      ds.field("axis", &self.axis());
      ds.field("batch_dims", &self.batch_dims());
      ds.finish()
  }
}
pub enum TransposeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeOptions<'a> {
  type Inner = TransposeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransposeOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransposeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TransposeOptionsArgs
  ) -> flatbuffers::WIPOffset<TransposeOptions<'bldr>> {
    let mut builder = TransposeOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for TransposeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TransposeOptionsArgs {
}
impl<'a> Default for TransposeOptionsArgs {
  #[inline]
  fn default() -> Self {
    TransposeOptionsArgs {
    }
  }
}

pub struct TransposeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransposeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransposeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransposeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransposeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransposeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransposeOptions");
      ds.finish()
  }
}
pub enum ExpOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpOptions<'a> {
  type Inner = ExpOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExpOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExpOptionsArgs
  ) -> flatbuffers::WIPOffset<ExpOptions<'bldr>> {
    let mut builder = ExpOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ExpOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ExpOptionsArgs {
}
impl<'a> Default for ExpOptionsArgs {
  #[inline]
  fn default() -> Self {
    ExpOptionsArgs {
    }
  }
}

pub struct ExpOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpOptions");
      ds.finish()
  }
}
pub enum CosOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CosOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CosOptions<'a> {
  type Inner = CosOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CosOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CosOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args CosOptionsArgs
  ) -> flatbuffers::WIPOffset<CosOptions<'bldr>> {
    let mut builder = CosOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for CosOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct CosOptionsArgs {
}
impl<'a> Default for CosOptionsArgs {
  #[inline]
  fn default() -> Self {
    CosOptionsArgs {
    }
  }
}

pub struct CosOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CosOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CosOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CosOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CosOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CosOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CosOptions");
      ds.finish()
  }
}
pub enum ReducerOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReducerOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReducerOptions<'a> {
  type Inner = ReducerOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReducerOptions<'a> {
  pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReducerOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReducerOptionsArgs
  ) -> flatbuffers::WIPOffset<ReducerOptions<'bldr>> {
    let mut builder = ReducerOptionsBuilder::new(_fbb);
    builder.add_keep_dims(args.keep_dims);
    builder.finish()
  }


  #[inline]
  pub fn keep_dims(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ReducerOptions::VT_KEEP_DIMS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ReducerOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ReducerOptionsArgs {
    pub keep_dims: bool,
}
impl<'a> Default for ReducerOptionsArgs {
  #[inline]
  fn default() -> Self {
    ReducerOptionsArgs {
      keep_dims: false,
    }
  }
}

pub struct ReducerOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReducerOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_keep_dims(&mut self, keep_dims: bool) {
    self.fbb_.push_slot::<bool>(ReducerOptions::VT_KEEP_DIMS, keep_dims, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReducerOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReducerOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReducerOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReducerOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReducerOptions");
      ds.field("keep_dims", &self.keep_dims());
      ds.finish()
  }
}
pub enum SqueezeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SqueezeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqueezeOptions<'a> {
  type Inner = SqueezeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SqueezeOptions<'a> {
  pub const VT_SQUEEZE_DIMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SqueezeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SqueezeOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<SqueezeOptions<'bldr>> {
    let mut builder = SqueezeOptionsBuilder::new(_fbb);
    if let Some(x) = args.squeeze_dims { builder.add_squeeze_dims(x); }
    builder.finish()
  }


  #[inline]
  pub fn squeeze_dims(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SqueezeOptions::VT_SQUEEZE_DIMS, None)}
  }
}

impl flatbuffers::Verifiable for SqueezeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("squeeze_dims", Self::VT_SQUEEZE_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SqueezeOptionsArgs<'a> {
    pub squeeze_dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for SqueezeOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    SqueezeOptionsArgs {
      squeeze_dims: None,
    }
  }
}

pub struct SqueezeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SqueezeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_squeeze_dims(&mut self, squeeze_dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SqueezeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SqueezeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SqueezeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SqueezeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SqueezeOptions");
      ds.field("squeeze_dims", &self.squeeze_dims());
      ds.finish()
  }
}
pub enum SplitOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitOptions<'a> {
  type Inner = SplitOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SplitOptions<'a> {
  pub const VT_NUM_SPLITS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SplitOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SplitOptionsArgs
  ) -> flatbuffers::WIPOffset<SplitOptions<'bldr>> {
    let mut builder = SplitOptionsBuilder::new(_fbb);
    builder.add_num_splits(args.num_splits);
    builder.finish()
  }


  #[inline]
  pub fn num_splits(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SplitOptions::VT_NUM_SPLITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SplitOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_splits", Self::VT_NUM_SPLITS, false)?
     .finish();
    Ok(())
  }
}
pub struct SplitOptionsArgs {
    pub num_splits: i32,
}
impl<'a> Default for SplitOptionsArgs {
  #[inline]
  fn default() -> Self {
    SplitOptionsArgs {
      num_splits: 0,
    }
  }
}

pub struct SplitOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplitOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_splits(&mut self, num_splits: i32) {
    self.fbb_.push_slot::<i32>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplitOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplitOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplitOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SplitOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SplitOptions");
      ds.field("num_splits", &self.num_splits());
      ds.finish()
  }
}
pub enum SplitVOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitVOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitVOptions<'a> {
  type Inner = SplitVOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SplitVOptions<'a> {
  pub const VT_NUM_SPLITS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SplitVOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SplitVOptionsArgs
  ) -> flatbuffers::WIPOffset<SplitVOptions<'bldr>> {
    let mut builder = SplitVOptionsBuilder::new(_fbb);
    builder.add_num_splits(args.num_splits);
    builder.finish()
  }


  #[inline]
  pub fn num_splits(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SplitVOptions::VT_NUM_SPLITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SplitVOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_splits", Self::VT_NUM_SPLITS, false)?
     .finish();
    Ok(())
  }
}
pub struct SplitVOptionsArgs {
    pub num_splits: i32,
}
impl<'a> Default for SplitVOptionsArgs {
  #[inline]
  fn default() -> Self {
    SplitVOptionsArgs {
      num_splits: 0,
    }
  }
}

pub struct SplitVOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplitVOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_splits(&mut self, num_splits: i32) {
    self.fbb_.push_slot::<i32>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplitVOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplitVOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplitVOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SplitVOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SplitVOptions");
      ds.field("num_splits", &self.num_splits());
      ds.finish()
  }
}
pub enum StridedSliceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StridedSliceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StridedSliceOptions<'a> {
  type Inner = StridedSliceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StridedSliceOptions<'a> {
  pub const VT_BEGIN_MASK: flatbuffers::VOffsetT = 4;
  pub const VT_END_MASK: flatbuffers::VOffsetT = 6;
  pub const VT_ELLIPSIS_MASK: flatbuffers::VOffsetT = 8;
  pub const VT_NEW_AXIS_MASK: flatbuffers::VOffsetT = 10;
  pub const VT_SHRINK_AXIS_MASK: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StridedSliceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StridedSliceOptionsArgs
  ) -> flatbuffers::WIPOffset<StridedSliceOptions<'bldr>> {
    let mut builder = StridedSliceOptionsBuilder::new(_fbb);
    builder.add_shrink_axis_mask(args.shrink_axis_mask);
    builder.add_new_axis_mask(args.new_axis_mask);
    builder.add_ellipsis_mask(args.ellipsis_mask);
    builder.add_end_mask(args.end_mask);
    builder.add_begin_mask(args.begin_mask);
    builder.finish()
  }


  #[inline]
  pub fn begin_mask(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StridedSliceOptions::VT_BEGIN_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn end_mask(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StridedSliceOptions::VT_END_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ellipsis_mask(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StridedSliceOptions::VT_ELLIPSIS_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn new_axis_mask(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StridedSliceOptions::VT_NEW_AXIS_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn shrink_axis_mask(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for StridedSliceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("begin_mask", Self::VT_BEGIN_MASK, false)?
     .visit_field::<i32>("end_mask", Self::VT_END_MASK, false)?
     .visit_field::<i32>("ellipsis_mask", Self::VT_ELLIPSIS_MASK, false)?
     .visit_field::<i32>("new_axis_mask", Self::VT_NEW_AXIS_MASK, false)?
     .visit_field::<i32>("shrink_axis_mask", Self::VT_SHRINK_AXIS_MASK, false)?
     .finish();
    Ok(())
  }
}
pub struct StridedSliceOptionsArgs {
    pub begin_mask: i32,
    pub end_mask: i32,
    pub ellipsis_mask: i32,
    pub new_axis_mask: i32,
    pub shrink_axis_mask: i32,
}
impl<'a> Default for StridedSliceOptionsArgs {
  #[inline]
  fn default() -> Self {
    StridedSliceOptionsArgs {
      begin_mask: 0,
      end_mask: 0,
      ellipsis_mask: 0,
      new_axis_mask: 0,
      shrink_axis_mask: 0,
    }
  }
}

pub struct StridedSliceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StridedSliceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_begin_mask(&mut self, begin_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  #[inline]
  pub fn add_end_mask(&mut self, end_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  #[inline]
  pub fn add_ellipsis_mask(&mut self, ellipsis_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  #[inline]
  pub fn add_new_axis_mask(&mut self, new_axis_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  #[inline]
  pub fn add_shrink_axis_mask(&mut self, shrink_axis_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StridedSliceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StridedSliceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StridedSliceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StridedSliceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StridedSliceOptions");
      ds.field("begin_mask", &self.begin_mask());
      ds.field("end_mask", &self.end_mask());
      ds.field("ellipsis_mask", &self.ellipsis_mask());
      ds.field("new_axis_mask", &self.new_axis_mask());
      ds.field("shrink_axis_mask", &self.shrink_axis_mask());
      ds.finish()
  }
}
pub enum LogSoftmaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogSoftmaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogSoftmaxOptions<'a> {
  type Inner = LogSoftmaxOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogSoftmaxOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogSoftmaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogSoftmaxOptionsArgs
  ) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'bldr>> {
    let mut builder = LogSoftmaxOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LogSoftmaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogSoftmaxOptionsArgs {
}
impl<'a> Default for LogSoftmaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogSoftmaxOptionsArgs {
    }
  }
}

pub struct LogSoftmaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogSoftmaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogSoftmaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogSoftmaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogSoftmaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogSoftmaxOptions");
      ds.finish()
  }
}
pub enum CastOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastOptions<'a> {
  type Inner = CastOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CastOptions<'a> {
  pub const VT_IN_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_DATA_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CastOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CastOptionsArgs
  ) -> flatbuffers::WIPOffset<CastOptions<'bldr>> {
    let mut builder = CastOptionsBuilder::new(_fbb);
    builder.add_out_data_type(args.out_data_type);
    builder.add_in_data_type(args.in_data_type);
    builder.finish()
  }


  #[inline]
  pub fn in_data_type(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(CastOptions::VT_IN_DATA_TYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
  #[inline]
  pub fn out_data_type(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(CastOptions::VT_OUT_DATA_TYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CastOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("in_data_type", Self::VT_IN_DATA_TYPE, false)?
     .visit_field::<TensorType>("out_data_type", Self::VT_OUT_DATA_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CastOptionsArgs {
    pub in_data_type: TensorType,
    pub out_data_type: TensorType,
}
impl<'a> Default for CastOptionsArgs {
  #[inline]
  fn default() -> Self {
    CastOptionsArgs {
      in_data_type: TensorType::FLOAT32,
      out_data_type: TensorType::FLOAT32,
    }
  }
}

pub struct CastOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_in_data_type(&mut self, in_data_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(CastOptions::VT_IN_DATA_TYPE, in_data_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn add_out_data_type(&mut self, out_data_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(CastOptions::VT_OUT_DATA_TYPE, out_data_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CastOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CastOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CastOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CastOptions");
      ds.field("in_data_type", &self.in_data_type());
      ds.field("out_data_type", &self.out_data_type());
      ds.finish()
  }
}
pub enum DequantizeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DequantizeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DequantizeOptions<'a> {
  type Inner = DequantizeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DequantizeOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DequantizeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args DequantizeOptionsArgs
  ) -> flatbuffers::WIPOffset<DequantizeOptions<'bldr>> {
    let mut builder = DequantizeOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for DequantizeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DequantizeOptionsArgs {
}
impl<'a> Default for DequantizeOptionsArgs {
  #[inline]
  fn default() -> Self {
    DequantizeOptionsArgs {
    }
  }
}

pub struct DequantizeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DequantizeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DequantizeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DequantizeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DequantizeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DequantizeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DequantizeOptions");
      ds.finish()
  }
}
pub enum MaximumMinimumOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaximumMinimumOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaximumMinimumOptions<'a> {
  type Inner = MaximumMinimumOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MaximumMinimumOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MaximumMinimumOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MaximumMinimumOptionsArgs
  ) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'bldr>> {
    let mut builder = MaximumMinimumOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for MaximumMinimumOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MaximumMinimumOptionsArgs {
}
impl<'a> Default for MaximumMinimumOptionsArgs {
  #[inline]
  fn default() -> Self {
    MaximumMinimumOptionsArgs {
    }
  }
}

pub struct MaximumMinimumOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaximumMinimumOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaximumMinimumOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MaximumMinimumOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MaximumMinimumOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MaximumMinimumOptions");
      ds.finish()
  }
}
pub enum TileOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TileOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TileOptions<'a> {
  type Inner = TileOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TileOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TileOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TileOptionsArgs
  ) -> flatbuffers::WIPOffset<TileOptions<'bldr>> {
    let mut builder = TileOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for TileOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TileOptionsArgs {
}
impl<'a> Default for TileOptionsArgs {
  #[inline]
  fn default() -> Self {
    TileOptionsArgs {
    }
  }
}

pub struct TileOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TileOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TileOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TileOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TileOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TileOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TileOptions");
      ds.finish()
  }
}
pub enum ArgMaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArgMaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgMaxOptions<'a> {
  type Inner = ArgMaxOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArgMaxOptions<'a> {
  pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgMaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArgMaxOptionsArgs
  ) -> flatbuffers::WIPOffset<ArgMaxOptions<'bldr>> {
    let mut builder = ArgMaxOptionsBuilder::new(_fbb);
    builder.add_output_type(args.output_type);
    builder.finish()
  }


  #[inline]
  pub fn output_type(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(ArgMaxOptions::VT_OUTPUT_TYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ArgMaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("output_type", Self::VT_OUTPUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgMaxOptionsArgs {
    pub output_type: TensorType,
}
impl<'a> Default for ArgMaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    ArgMaxOptionsArgs {
      output_type: TensorType::FLOAT32,
    }
  }
}

pub struct ArgMaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArgMaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_output_type(&mut self, output_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(ArgMaxOptions::VT_OUTPUT_TYPE, output_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgMaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArgMaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgMaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgMaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgMaxOptions");
      ds.field("output_type", &self.output_type());
      ds.finish()
  }
}
pub enum ArgMinOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArgMinOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgMinOptions<'a> {
  type Inner = ArgMinOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArgMinOptions<'a> {
  pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgMinOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArgMinOptionsArgs
  ) -> flatbuffers::WIPOffset<ArgMinOptions<'bldr>> {
    let mut builder = ArgMinOptionsBuilder::new(_fbb);
    builder.add_output_type(args.output_type);
    builder.finish()
  }


  #[inline]
  pub fn output_type(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(ArgMinOptions::VT_OUTPUT_TYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ArgMinOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("output_type", Self::VT_OUTPUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgMinOptionsArgs {
    pub output_type: TensorType,
}
impl<'a> Default for ArgMinOptionsArgs {
  #[inline]
  fn default() -> Self {
    ArgMinOptionsArgs {
      output_type: TensorType::FLOAT32,
    }
  }
}

pub struct ArgMinOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArgMinOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_output_type(&mut self, output_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(ArgMinOptions::VT_OUTPUT_TYPE, output_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgMinOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArgMinOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgMinOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgMinOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgMinOptions");
      ds.field("output_type", &self.output_type());
      ds.finish()
  }
}
pub enum GreaterOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GreaterOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GreaterOptions<'a> {
  type Inner = GreaterOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GreaterOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GreaterOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GreaterOptionsArgs
  ) -> flatbuffers::WIPOffset<GreaterOptions<'bldr>> {
    let mut builder = GreaterOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for GreaterOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GreaterOptionsArgs {
}
impl<'a> Default for GreaterOptionsArgs {
  #[inline]
  fn default() -> Self {
    GreaterOptionsArgs {
    }
  }
}

pub struct GreaterOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GreaterOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GreaterOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GreaterOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GreaterOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GreaterOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GreaterOptions");
      ds.finish()
  }
}
pub enum GreaterEqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GreaterEqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GreaterEqualOptions<'a> {
  type Inner = GreaterEqualOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GreaterEqualOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GreaterEqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GreaterEqualOptionsArgs
  ) -> flatbuffers::WIPOffset<GreaterEqualOptions<'bldr>> {
    let mut builder = GreaterEqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for GreaterEqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GreaterEqualOptionsArgs {
}
impl<'a> Default for GreaterEqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    GreaterEqualOptionsArgs {
    }
  }
}

pub struct GreaterEqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GreaterEqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GreaterEqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GreaterEqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GreaterEqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GreaterEqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GreaterEqualOptions");
      ds.finish()
  }
}
pub enum LessOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LessOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LessOptions<'a> {
  type Inner = LessOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LessOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LessOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LessOptionsArgs
  ) -> flatbuffers::WIPOffset<LessOptions<'bldr>> {
    let mut builder = LessOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LessOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LessOptionsArgs {
}
impl<'a> Default for LessOptionsArgs {
  #[inline]
  fn default() -> Self {
    LessOptionsArgs {
    }
  }
}

pub struct LessOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LessOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LessOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LessOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LessOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LessOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LessOptions");
      ds.finish()
  }
}
pub enum LessEqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LessEqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LessEqualOptions<'a> {
  type Inner = LessEqualOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LessEqualOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LessEqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LessEqualOptionsArgs
  ) -> flatbuffers::WIPOffset<LessEqualOptions<'bldr>> {
    let mut builder = LessEqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LessEqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LessEqualOptionsArgs {
}
impl<'a> Default for LessEqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    LessEqualOptionsArgs {
    }
  }
}

pub struct LessEqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LessEqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LessEqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LessEqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LessEqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LessEqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LessEqualOptions");
      ds.finish()
  }
}
pub enum NegOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NegOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NegOptions<'a> {
  type Inner = NegOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NegOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NegOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NegOptionsArgs
  ) -> flatbuffers::WIPOffset<NegOptions<'bldr>> {
    let mut builder = NegOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for NegOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NegOptionsArgs {
}
impl<'a> Default for NegOptionsArgs {
  #[inline]
  fn default() -> Self {
    NegOptionsArgs {
    }
  }
}

pub struct NegOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NegOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NegOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NegOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NegOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NegOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NegOptions");
      ds.finish()
  }
}
pub enum SelectOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SelectOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SelectOptions<'a> {
  type Inner = SelectOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SelectOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SelectOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SelectOptionsArgs
  ) -> flatbuffers::WIPOffset<SelectOptions<'bldr>> {
    let mut builder = SelectOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SelectOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SelectOptionsArgs {
}
impl<'a> Default for SelectOptionsArgs {
  #[inline]
  fn default() -> Self {
    SelectOptionsArgs {
    }
  }
}

pub struct SelectOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SelectOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SelectOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SelectOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SelectOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SelectOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SelectOptions");
      ds.finish()
  }
}
pub enum SliceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SliceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SliceOptions<'a> {
  type Inner = SliceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SliceOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SliceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SliceOptionsArgs
  ) -> flatbuffers::WIPOffset<SliceOptions<'bldr>> {
    let mut builder = SliceOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SliceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SliceOptionsArgs {
}
impl<'a> Default for SliceOptionsArgs {
  #[inline]
  fn default() -> Self {
    SliceOptionsArgs {
    }
  }
}

pub struct SliceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SliceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SliceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SliceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SliceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SliceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SliceOptions");
      ds.finish()
  }
}
pub enum TransposeConvOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeConvOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeConvOptions<'a> {
  type Inner = TransposeConvOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransposeConvOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransposeConvOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TransposeConvOptionsArgs
  ) -> flatbuffers::WIPOffset<TransposeConvOptions<'bldr>> {
    let mut builder = TransposeConvOptionsBuilder::new(_fbb);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }


  #[inline]
  pub fn padding(&self) -> Padding {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Padding>(TransposeConvOptions::VT_PADDING, Some(Padding::SAME)).unwrap()}
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TransposeConvOptions::VT_STRIDE_W, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TransposeConvOptions::VT_STRIDE_H, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActivationFunctionType>(TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TransposeConvOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct TransposeConvOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for TransposeConvOptionsArgs {
  #[inline]
  fn default() -> Self {
    TransposeConvOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct TransposeConvOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransposeConvOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(TransposeConvOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransposeConvOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransposeConvOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransposeConvOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransposeConvOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransposeConvOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
pub enum ExpandDimsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpandDimsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpandDimsOptions<'a> {
  type Inner = ExpandDimsOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExpandDimsOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpandDimsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExpandDimsOptionsArgs
  ) -> flatbuffers::WIPOffset<ExpandDimsOptions<'bldr>> {
    let mut builder = ExpandDimsOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ExpandDimsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ExpandDimsOptionsArgs {
}
impl<'a> Default for ExpandDimsOptionsArgs {
  #[inline]
  fn default() -> Self {
    ExpandDimsOptionsArgs {
    }
  }
}

pub struct ExpandDimsOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpandDimsOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpandDimsOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpandDimsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpandDimsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpandDimsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpandDimsOptions");
      ds.finish()
  }
}
pub enum SparseToDenseOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseToDenseOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseToDenseOptions<'a> {
  type Inner = SparseToDenseOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SparseToDenseOptions<'a> {
  pub const VT_VALIDATE_INDICES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparseToDenseOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SparseToDenseOptionsArgs
  ) -> flatbuffers::WIPOffset<SparseToDenseOptions<'bldr>> {
    let mut builder = SparseToDenseOptionsBuilder::new(_fbb);
    builder.add_validate_indices(args.validate_indices);
    builder.finish()
  }


  #[inline]
  pub fn validate_indices(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SparseToDenseOptions::VT_VALIDATE_INDICES, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SparseToDenseOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("validate_indices", Self::VT_VALIDATE_INDICES, false)?
     .finish();
    Ok(())
  }
}
pub struct SparseToDenseOptionsArgs {
    pub validate_indices: bool,
}
impl<'a> Default for SparseToDenseOptionsArgs {
  #[inline]
  fn default() -> Self {
    SparseToDenseOptionsArgs {
      validate_indices: false,
    }
  }
}

pub struct SparseToDenseOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SparseToDenseOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_validate_indices(&mut self, validate_indices: bool) {
    self.fbb_.push_slot::<bool>(SparseToDenseOptions::VT_VALIDATE_INDICES, validate_indices, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SparseToDenseOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SparseToDenseOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparseToDenseOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparseToDenseOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparseToDenseOptions");
      ds.field("validate_indices", &self.validate_indices());
      ds.finish()
  }
}
pub enum EqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EqualOptions<'a> {
  type Inner = EqualOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EqualOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args EqualOptionsArgs
  ) -> flatbuffers::WIPOffset<EqualOptions<'bldr>> {
    let mut builder = EqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for EqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct EqualOptionsArgs {
}
impl<'a> Default for EqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    EqualOptionsArgs {
    }
  }
}

pub struct EqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EqualOptions");
      ds.finish()
  }
}
pub enum NotEqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NotEqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NotEqualOptions<'a> {
  type Inner = NotEqualOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NotEqualOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NotEqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NotEqualOptionsArgs
  ) -> flatbuffers::WIPOffset<NotEqualOptions<'bldr>> {
    let mut builder = NotEqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for NotEqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NotEqualOptionsArgs {
}
impl<'a> Default for NotEqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    NotEqualOptionsArgs {
    }
  }
}

pub struct NotEqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NotEqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NotEqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NotEqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NotEqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NotEqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NotEqualOptions");
      ds.finish()
  }
}
pub enum ShapeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShapeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShapeOptions<'a> {
  type Inner = ShapeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShapeOptions<'a> {
  pub const VT_OUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShapeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShapeOptionsArgs
  ) -> flatbuffers::WIPOffset<ShapeOptions<'bldr>> {
    let mut builder = ShapeOptionsBuilder::new(_fbb);
    builder.add_out_type(args.out_type);
    builder.finish()
  }


  #[inline]
  pub fn out_type(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(ShapeOptions::VT_OUT_TYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ShapeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("out_type", Self::VT_OUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ShapeOptionsArgs {
    pub out_type: TensorType,
}
impl<'a> Default for ShapeOptionsArgs {
  #[inline]
  fn default() -> Self {
    ShapeOptionsArgs {
      out_type: TensorType::FLOAT32,
    }
  }
}

pub struct ShapeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShapeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_out_type(&mut self, out_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(ShapeOptions::VT_OUT_TYPE, out_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShapeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShapeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShapeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShapeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShapeOptions");
      ds.field("out_type", &self.out_type());
      ds.finish()
  }
}
pub enum RankOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RankOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RankOptions<'a> {
  type Inner = RankOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RankOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RankOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RankOptionsArgs
  ) -> flatbuffers::WIPOffset<RankOptions<'bldr>> {
    let mut builder = RankOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for RankOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RankOptionsArgs {
}
impl<'a> Default for RankOptionsArgs {
  #[inline]
  fn default() -> Self {
    RankOptionsArgs {
    }
  }
}

pub struct RankOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RankOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RankOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RankOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RankOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RankOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RankOptions");
      ds.finish()
  }
}
pub enum PowOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PowOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PowOptions<'a> {
  type Inner = PowOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PowOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PowOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PowOptionsArgs
  ) -> flatbuffers::WIPOffset<PowOptions<'bldr>> {
    let mut builder = PowOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for PowOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PowOptionsArgs {
}
impl<'a> Default for PowOptionsArgs {
  #[inline]
  fn default() -> Self {
    PowOptionsArgs {
    }
  }
}

pub struct PowOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PowOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PowOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PowOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PowOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PowOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PowOptions");
      ds.finish()
  }
}
pub enum FakeQuantOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FakeQuantOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FakeQuantOptions<'a> {
  type Inner = FakeQuantOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FakeQuantOptions<'a> {
  pub const VT_MIN: flatbuffers::VOffsetT = 4;
  pub const VT_MAX: flatbuffers::VOffsetT = 6;
  pub const VT_NUM_BITS: flatbuffers::VOffsetT = 8;
  pub const VT_NARROW_RANGE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FakeQuantOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FakeQuantOptionsArgs
  ) -> flatbuffers::WIPOffset<FakeQuantOptions<'bldr>> {
    let mut builder = FakeQuantOptionsBuilder::new(_fbb);
    builder.add_num_bits(args.num_bits);
    builder.add_max(args.max);
    builder.add_min(args.min);
    builder.add_narrow_range(args.narrow_range);
    builder.finish()
  }


  #[inline]
  pub fn min(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FakeQuantOptions::VT_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn max(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FakeQuantOptions::VT_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn num_bits(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(FakeQuantOptions::VT_NUM_BITS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn narrow_range(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FakeQuantOptions::VT_NARROW_RANGE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FakeQuantOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("min", Self::VT_MIN, false)?
     .visit_field::<f32>("max", Self::VT_MAX, false)?
     .visit_field::<i32>("num_bits", Self::VT_NUM_BITS, false)?
     .visit_field::<bool>("narrow_range", Self::VT_NARROW_RANGE, false)?
     .finish();
    Ok(())
  }
}
pub struct FakeQuantOptionsArgs {
    pub min: f32,
    pub max: f32,
    pub num_bits: i32,
    pub narrow_range: bool,
}
impl<'a> Default for FakeQuantOptionsArgs {
  #[inline]
  fn default() -> Self {
    FakeQuantOptionsArgs {
      min: 0.0,
      max: 0.0,
      num_bits: 0,
      narrow_range: false,
    }
  }
}

pub struct FakeQuantOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FakeQuantOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_min(&mut self, min: f32) {
    self.fbb_.push_slot::<f32>(FakeQuantOptions::VT_MIN, min, 0.0);
  }
  #[inline]
  pub fn add_max(&mut self, max: f32) {
    self.fbb_.push_slot::<f32>(FakeQuantOptions::VT_MAX, max, 0.0);
  }
  #[inline]
  pub fn add_num_bits(&mut self, num_bits: i32) {
    self.fbb_.push_slot::<i32>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  #[inline]
  pub fn add_narrow_range(&mut self, narrow_range: bool) {
    self.fbb_.push_slot::<bool>(FakeQuantOptions::VT_NARROW_RANGE, narrow_range, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FakeQuantOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FakeQuantOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FakeQuantOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FakeQuantOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FakeQuantOptions");
      ds.field("min", &self.min());
      ds.field("max", &self.max());
      ds.field("num_bits", &self.num_bits());
      ds.field("narrow_range", &self.narrow_range());
      ds.finish()
  }
}
pub enum PackOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PackOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PackOptions<'a> {
  type Inner = PackOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PackOptions<'a> {
  pub const VT_VALUES_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_AXIS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PackOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PackOptionsArgs
  ) -> flatbuffers::WIPOffset<PackOptions<'bldr>> {
    let mut builder = PackOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.add_values_count(args.values_count);
    builder.finish()
  }


  #[inline]
  pub fn values_count(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PackOptions::VT_VALUES_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn axis(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PackOptions::VT_AXIS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PackOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("values_count", Self::VT_VALUES_COUNT, false)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct PackOptionsArgs {
    pub values_count: i32,
    pub axis: i32,
}
impl<'a> Default for PackOptionsArgs {
  #[inline]
  fn default() -> Self {
    PackOptionsArgs {
      values_count: 0,
      axis: 0,
    }
  }
}

pub struct PackOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PackOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_values_count(&mut self, values_count: i32) {
    self.fbb_.push_slot::<i32>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(PackOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PackOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PackOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PackOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PackOptions");
      ds.field("values_count", &self.values_count());
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
pub enum LogicalOrOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogicalOrOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalOrOptions<'a> {
  type Inner = LogicalOrOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogicalOrOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogicalOrOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogicalOrOptionsArgs
  ) -> flatbuffers::WIPOffset<LogicalOrOptions<'bldr>> {
    let mut builder = LogicalOrOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LogicalOrOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogicalOrOptionsArgs {
}
impl<'a> Default for LogicalOrOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogicalOrOptionsArgs {
    }
  }
}

pub struct LogicalOrOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalOrOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalOrOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalOrOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalOrOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogicalOrOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogicalOrOptions");
      ds.finish()
  }
}
pub enum OneHotOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OneHotOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OneHotOptions<'a> {
  type Inner = OneHotOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OneHotOptions<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OneHotOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OneHotOptionsArgs
  ) -> flatbuffers::WIPOffset<OneHotOptions<'bldr>> {
    let mut builder = OneHotOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.finish()
  }


  #[inline]
  pub fn axis(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OneHotOptions::VT_AXIS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OneHotOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct OneHotOptionsArgs {
    pub axis: i32,
}
impl<'a> Default for OneHotOptionsArgs {
  #[inline]
  fn default() -> Self {
    OneHotOptionsArgs {
      axis: 0,
    }
  }
}

pub struct OneHotOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OneHotOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(OneHotOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OneHotOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OneHotOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OneHotOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OneHotOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OneHotOptions");
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
pub enum AbsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AbsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbsOptions<'a> {
  type Inner = AbsOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AbsOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AbsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AbsOptionsArgs
  ) -> flatbuffers::WIPOffset<AbsOptions<'bldr>> {
    let mut builder = AbsOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AbsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AbsOptionsArgs {
}
impl<'a> Default for AbsOptionsArgs {
  #[inline]
  fn default() -> Self {
    AbsOptionsArgs {
    }
  }
}

pub struct AbsOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AbsOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AbsOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AbsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AbsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AbsOptions");
      ds.finish()
  }
}
pub enum HardSwishOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HardSwishOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HardSwishOptions<'a> {
  type Inner = HardSwishOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HardSwishOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HardSwishOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HardSwishOptionsArgs
  ) -> flatbuffers::WIPOffset<HardSwishOptions<'bldr>> {
    let mut builder = HardSwishOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for HardSwishOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HardSwishOptionsArgs {
}
impl<'a> Default for HardSwishOptionsArgs {
  #[inline]
  fn default() -> Self {
    HardSwishOptionsArgs {
    }
  }
}

pub struct HardSwishOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HardSwishOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HardSwishOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HardSwishOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HardSwishOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HardSwishOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HardSwishOptions");
      ds.finish()
  }
}
pub enum LogicalAndOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogicalAndOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalAndOptions<'a> {
  type Inner = LogicalAndOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogicalAndOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogicalAndOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogicalAndOptionsArgs
  ) -> flatbuffers::WIPOffset<LogicalAndOptions<'bldr>> {
    let mut builder = LogicalAndOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LogicalAndOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogicalAndOptionsArgs {
}
impl<'a> Default for LogicalAndOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogicalAndOptionsArgs {
    }
  }
}

pub struct LogicalAndOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalAndOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalAndOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalAndOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalAndOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogicalAndOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogicalAndOptions");
      ds.finish()
  }
}
pub enum LogicalNotOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogicalNotOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalNotOptions<'a> {
  type Inner = LogicalNotOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogicalNotOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogicalNotOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogicalNotOptionsArgs
  ) -> flatbuffers::WIPOffset<LogicalNotOptions<'bldr>> {
    let mut builder = LogicalNotOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LogicalNotOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogicalNotOptionsArgs {
}
impl<'a> Default for LogicalNotOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogicalNotOptionsArgs {
    }
  }
}

pub struct LogicalNotOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalNotOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalNotOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalNotOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalNotOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogicalNotOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogicalNotOptions");
      ds.finish()
  }
}
pub enum UnpackOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnpackOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnpackOptions<'a> {
  type Inner = UnpackOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnpackOptions<'a> {
  pub const VT_NUM: flatbuffers::VOffsetT = 4;
  pub const VT_AXIS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnpackOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnpackOptionsArgs
  ) -> flatbuffers::WIPOffset<UnpackOptions<'bldr>> {
    let mut builder = UnpackOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.add_num(args.num);
    builder.finish()
  }


  #[inline]
  pub fn num(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UnpackOptions::VT_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn axis(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UnpackOptions::VT_AXIS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UnpackOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num", Self::VT_NUM, false)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct UnpackOptionsArgs {
    pub num: i32,
    pub axis: i32,
}
impl<'a> Default for UnpackOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnpackOptionsArgs {
      num: 0,
      axis: 0,
    }
  }
}

pub struct UnpackOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnpackOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num(&mut self, num: i32) {
    self.fbb_.push_slot::<i32>(UnpackOptions::VT_NUM, num, 0);
  }
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(UnpackOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnpackOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnpackOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnpackOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnpackOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnpackOptions");
      ds.field("num", &self.num());
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
pub enum FloorDivOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloorDivOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloorDivOptions<'a> {
  type Inner = FloorDivOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloorDivOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloorDivOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FloorDivOptionsArgs
  ) -> flatbuffers::WIPOffset<FloorDivOptions<'bldr>> {
    let mut builder = FloorDivOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for FloorDivOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FloorDivOptionsArgs {
}
impl<'a> Default for FloorDivOptionsArgs {
  #[inline]
  fn default() -> Self {
    FloorDivOptionsArgs {
    }
  }
}

pub struct FloorDivOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloorDivOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloorDivOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloorDivOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloorDivOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloorDivOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloorDivOptions");
      ds.finish()
  }
}
pub enum SquareOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SquareOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SquareOptions<'a> {
  type Inner = SquareOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SquareOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SquareOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SquareOptionsArgs
  ) -> flatbuffers::WIPOffset<SquareOptions<'bldr>> {
    let mut builder = SquareOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SquareOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SquareOptionsArgs {
}
impl<'a> Default for SquareOptionsArgs {
  #[inline]
  fn default() -> Self {
    SquareOptionsArgs {
    }
  }
}

pub struct SquareOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SquareOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SquareOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SquareOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SquareOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SquareOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SquareOptions");
      ds.finish()
  }
}
pub enum ZerosLikeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZerosLikeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZerosLikeOptions<'a> {
  type Inner = ZerosLikeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZerosLikeOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZerosLikeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ZerosLikeOptionsArgs
  ) -> flatbuffers::WIPOffset<ZerosLikeOptions<'bldr>> {
    let mut builder = ZerosLikeOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ZerosLikeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ZerosLikeOptionsArgs {
}
impl<'a> Default for ZerosLikeOptionsArgs {
  #[inline]
  fn default() -> Self {
    ZerosLikeOptionsArgs {
    }
  }
}

pub struct ZerosLikeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ZerosLikeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ZerosLikeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ZerosLikeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZerosLikeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZerosLikeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZerosLikeOptions");
      ds.finish()
  }
}
pub enum FillOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FillOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FillOptions<'a> {
  type Inner = FillOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FillOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FillOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FillOptionsArgs
  ) -> flatbuffers::WIPOffset<FillOptions<'bldr>> {
    let mut builder = FillOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for FillOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FillOptionsArgs {
}
impl<'a> Default for FillOptionsArgs {
  #[inline]
  fn default() -> Self {
    FillOptionsArgs {
    }
  }
}

pub struct FillOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FillOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FillOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FillOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FillOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FillOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FillOptions");
      ds.finish()
  }
}
pub enum FloorModOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloorModOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloorModOptions<'a> {
  type Inner = FloorModOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloorModOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloorModOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FloorModOptionsArgs
  ) -> flatbuffers::WIPOffset<FloorModOptions<'bldr>> {
    let mut builder = FloorModOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for FloorModOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FloorModOptionsArgs {
}
impl<'a> Default for FloorModOptionsArgs {
  #[inline]
  fn default() -> Self {
    FloorModOptionsArgs {
    }
  }
}

pub struct FloorModOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloorModOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloorModOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloorModOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloorModOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloorModOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloorModOptions");
      ds.finish()
  }
}
pub enum RangeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeOptions<'a> {
  type Inner = RangeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RangeOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RangeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RangeOptionsArgs
  ) -> flatbuffers::WIPOffset<RangeOptions<'bldr>> {
    let mut builder = RangeOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for RangeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RangeOptionsArgs {
}
impl<'a> Default for RangeOptionsArgs {
  #[inline]
  fn default() -> Self {
    RangeOptionsArgs {
    }
  }
}

pub struct RangeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RangeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RangeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RangeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RangeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RangeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RangeOptions");
      ds.finish()
  }
}
pub enum LeakyReluOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeakyReluOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeakyReluOptions<'a> {
  type Inner = LeakyReluOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LeakyReluOptions<'a> {
  pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeakyReluOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LeakyReluOptionsArgs
  ) -> flatbuffers::WIPOffset<LeakyReluOptions<'bldr>> {
    let mut builder = LeakyReluOptionsBuilder::new(_fbb);
    builder.add_alpha(args.alpha);
    builder.finish()
  }


  #[inline]
  pub fn alpha(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LeakyReluOptions::VT_ALPHA, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LeakyReluOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
     .finish();
    Ok(())
  }
}
pub struct LeakyReluOptionsArgs {
    pub alpha: f32,
}
impl<'a> Default for LeakyReluOptionsArgs {
  #[inline]
  fn default() -> Self {
    LeakyReluOptionsArgs {
      alpha: 0.0,
    }
  }
}

pub struct LeakyReluOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeakyReluOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_alpha(&mut self, alpha: f32) {
    self.fbb_.push_slot::<f32>(LeakyReluOptions::VT_ALPHA, alpha, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeakyReluOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeakyReluOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeakyReluOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeakyReluOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeakyReluOptions");
      ds.field("alpha", &self.alpha());
      ds.finish()
  }
}
pub enum SquaredDifferenceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SquaredDifferenceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SquaredDifferenceOptions<'a> {
  type Inner = SquaredDifferenceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SquaredDifferenceOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SquaredDifferenceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SquaredDifferenceOptionsArgs
  ) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'bldr>> {
    let mut builder = SquaredDifferenceOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SquaredDifferenceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SquaredDifferenceOptionsArgs {
}
impl<'a> Default for SquaredDifferenceOptionsArgs {
  #[inline]
  fn default() -> Self {
    SquaredDifferenceOptionsArgs {
    }
  }
}

pub struct SquaredDifferenceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SquaredDifferenceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SquaredDifferenceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SquaredDifferenceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SquaredDifferenceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SquaredDifferenceOptions");
      ds.finish()
  }
}
pub enum MirrorPadOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MirrorPadOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MirrorPadOptions<'a> {
  type Inner = MirrorPadOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MirrorPadOptions<'a> {
  pub const VT_MODE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MirrorPadOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MirrorPadOptionsArgs
  ) -> flatbuffers::WIPOffset<MirrorPadOptions<'bldr>> {
    let mut builder = MirrorPadOptionsBuilder::new(_fbb);
    builder.add_mode(args.mode);
    builder.finish()
  }


  #[inline]
  pub fn mode(&self) -> MirrorPadMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MirrorPadMode>(MirrorPadOptions::VT_MODE, Some(MirrorPadMode::REFLECT)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MirrorPadOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MirrorPadMode>("mode", Self::VT_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct MirrorPadOptionsArgs {
    pub mode: MirrorPadMode,
}
impl<'a> Default for MirrorPadOptionsArgs {
  #[inline]
  fn default() -> Self {
    MirrorPadOptionsArgs {
      mode: MirrorPadMode::REFLECT,
    }
  }
}

pub struct MirrorPadOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MirrorPadOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_mode(&mut self, mode: MirrorPadMode) {
    self.fbb_.push_slot::<MirrorPadMode>(MirrorPadOptions::VT_MODE, mode, MirrorPadMode::REFLECT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MirrorPadOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MirrorPadOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MirrorPadOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MirrorPadOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MirrorPadOptions");
      ds.field("mode", &self.mode());
      ds.finish()
  }
}
pub enum UniqueOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UniqueOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UniqueOptions<'a> {
  type Inner = UniqueOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UniqueOptions<'a> {
  pub const VT_IDX_OUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UniqueOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UniqueOptionsArgs
  ) -> flatbuffers::WIPOffset<UniqueOptions<'bldr>> {
    let mut builder = UniqueOptionsBuilder::new(_fbb);
    builder.add_idx_out_type(args.idx_out_type);
    builder.finish()
  }


  #[inline]
  pub fn idx_out_type(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(UniqueOptions::VT_IDX_OUT_TYPE, Some(TensorType::INT32)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UniqueOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("idx_out_type", Self::VT_IDX_OUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct UniqueOptionsArgs {
    pub idx_out_type: TensorType,
}
impl<'a> Default for UniqueOptionsArgs {
  #[inline]
  fn default() -> Self {
    UniqueOptionsArgs {
      idx_out_type: TensorType::INT32,
    }
  }
}

pub struct UniqueOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UniqueOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_idx_out_type(&mut self, idx_out_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(UniqueOptions::VT_IDX_OUT_TYPE, idx_out_type, TensorType::INT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UniqueOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UniqueOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UniqueOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UniqueOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UniqueOptions");
      ds.field("idx_out_type", &self.idx_out_type());
      ds.finish()
  }
}
pub enum ReverseV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReverseV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseV2Options<'a> {
  type Inner = ReverseV2Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReverseV2Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReverseV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ReverseV2OptionsArgs
  ) -> flatbuffers::WIPOffset<ReverseV2Options<'bldr>> {
    let mut builder = ReverseV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ReverseV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReverseV2OptionsArgs {
}
impl<'a> Default for ReverseV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    ReverseV2OptionsArgs {
    }
  }
}

pub struct ReverseV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReverseV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReverseV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReverseV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReverseV2Options");
      ds.finish()
  }
}
pub enum AddNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AddNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddNOptions<'a> {
  type Inner = AddNOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AddNOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AddNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AddNOptionsArgs
  ) -> flatbuffers::WIPOffset<AddNOptions<'bldr>> {
    let mut builder = AddNOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AddNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AddNOptionsArgs {
}
impl<'a> Default for AddNOptionsArgs {
  #[inline]
  fn default() -> Self {
    AddNOptionsArgs {
    }
  }
}

pub struct AddNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AddNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AddNOptions");
      ds.finish()
  }
}
pub enum GatherNdOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherNdOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherNdOptions<'a> {
  type Inner = GatherNdOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatherNdOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatherNdOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GatherNdOptionsArgs
  ) -> flatbuffers::WIPOffset<GatherNdOptions<'bldr>> {
    let mut builder = GatherNdOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for GatherNdOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GatherNdOptionsArgs {
}
impl<'a> Default for GatherNdOptionsArgs {
  #[inline]
  fn default() -> Self {
    GatherNdOptionsArgs {
    }
  }
}

pub struct GatherNdOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatherNdOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatherNdOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatherNdOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatherNdOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatherNdOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatherNdOptions");
      ds.finish()
  }
}
pub enum WhereOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WhereOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WhereOptions<'a> {
  type Inner = WhereOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WhereOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WhereOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args WhereOptionsArgs
  ) -> flatbuffers::WIPOffset<WhereOptions<'bldr>> {
    let mut builder = WhereOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for WhereOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct WhereOptionsArgs {
}
impl<'a> Default for WhereOptionsArgs {
  #[inline]
  fn default() -> Self {
    WhereOptionsArgs {
    }
  }
}

pub struct WhereOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WhereOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WhereOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WhereOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WhereOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WhereOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WhereOptions");
      ds.finish()
  }
}
pub enum ReverseSequenceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReverseSequenceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseSequenceOptions<'a> {
  type Inner = ReverseSequenceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReverseSequenceOptions<'a> {
  pub const VT_SEQ_DIM: flatbuffers::VOffsetT = 4;
  pub const VT_BATCH_DIM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReverseSequenceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReverseSequenceOptionsArgs
  ) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'bldr>> {
    let mut builder = ReverseSequenceOptionsBuilder::new(_fbb);
    builder.add_batch_dim(args.batch_dim);
    builder.add_seq_dim(args.seq_dim);
    builder.finish()
  }


  #[inline]
  pub fn seq_dim(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ReverseSequenceOptions::VT_SEQ_DIM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn batch_dim(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ReverseSequenceOptions::VT_BATCH_DIM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ReverseSequenceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("seq_dim", Self::VT_SEQ_DIM, false)?
     .visit_field::<i32>("batch_dim", Self::VT_BATCH_DIM, false)?
     .finish();
    Ok(())
  }
}
pub struct ReverseSequenceOptionsArgs {
    pub seq_dim: i32,
    pub batch_dim: i32,
}
impl<'a> Default for ReverseSequenceOptionsArgs {
  #[inline]
  fn default() -> Self {
    ReverseSequenceOptionsArgs {
      seq_dim: 0,
      batch_dim: 0,
    }
  }
}

pub struct ReverseSequenceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseSequenceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_seq_dim(&mut self, seq_dim: i32) {
    self.fbb_.push_slot::<i32>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  #[inline]
  pub fn add_batch_dim(&mut self, batch_dim: i32) {
    self.fbb_.push_slot::<i32>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseSequenceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReverseSequenceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReverseSequenceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReverseSequenceOptions");
      ds.field("seq_dim", &self.seq_dim());
      ds.field("batch_dim", &self.batch_dim());
      ds.finish()
  }
}
pub enum MatrixDiagOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatrixDiagOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatrixDiagOptions<'a> {
  type Inner = MatrixDiagOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatrixDiagOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatrixDiagOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MatrixDiagOptionsArgs
  ) -> flatbuffers::WIPOffset<MatrixDiagOptions<'bldr>> {
    let mut builder = MatrixDiagOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for MatrixDiagOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MatrixDiagOptionsArgs {
}
impl<'a> Default for MatrixDiagOptionsArgs {
  #[inline]
  fn default() -> Self {
    MatrixDiagOptionsArgs {
    }
  }
}

pub struct MatrixDiagOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatrixDiagOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatrixDiagOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatrixDiagOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatrixDiagOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatrixDiagOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatrixDiagOptions");
      ds.finish()
  }
}
pub enum QuantizeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuantizeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuantizeOptions<'a> {
  type Inner = QuantizeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QuantizeOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuantizeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QuantizeOptionsArgs
  ) -> flatbuffers::WIPOffset<QuantizeOptions<'bldr>> {
    let mut builder = QuantizeOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QuantizeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QuantizeOptionsArgs {
}
impl<'a> Default for QuantizeOptionsArgs {
  #[inline]
  fn default() -> Self {
    QuantizeOptionsArgs {
    }
  }
}

pub struct QuantizeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuantizeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuantizeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuantizeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuantizeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuantizeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuantizeOptions");
      ds.finish()
  }
}
pub enum MatrixSetDiagOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatrixSetDiagOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatrixSetDiagOptions<'a> {
  type Inner = MatrixSetDiagOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatrixSetDiagOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatrixSetDiagOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MatrixSetDiagOptionsArgs
  ) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'bldr>> {
    let mut builder = MatrixSetDiagOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for MatrixSetDiagOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MatrixSetDiagOptionsArgs {
}
impl<'a> Default for MatrixSetDiagOptionsArgs {
  #[inline]
  fn default() -> Self {
    MatrixSetDiagOptionsArgs {
    }
  }
}

pub struct MatrixSetDiagOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatrixSetDiagOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatrixSetDiagOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatrixSetDiagOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatrixSetDiagOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatrixSetDiagOptions");
      ds.finish()
  }
}
pub enum IfOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IfOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IfOptions<'a> {
  type Inner = IfOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IfOptions<'a> {
  pub const VT_THEN_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_ELSE_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IfOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IfOptionsArgs
  ) -> flatbuffers::WIPOffset<IfOptions<'bldr>> {
    let mut builder = IfOptionsBuilder::new(_fbb);
    builder.add_else_subgraph_index(args.else_subgraph_index);
    builder.add_then_subgraph_index(args.then_subgraph_index);
    builder.finish()
  }


  #[inline]
  pub fn then_subgraph_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(IfOptions::VT_THEN_SUBGRAPH_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn else_subgraph_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IfOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("then_subgraph_index", Self::VT_THEN_SUBGRAPH_INDEX, false)?
     .visit_field::<i32>("else_subgraph_index", Self::VT_ELSE_SUBGRAPH_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct IfOptionsArgs {
    pub then_subgraph_index: i32,
    pub else_subgraph_index: i32,
}
impl<'a> Default for IfOptionsArgs {
  #[inline]
  fn default() -> Self {
    IfOptionsArgs {
      then_subgraph_index: 0,
      else_subgraph_index: 0,
    }
  }
}

pub struct IfOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IfOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_then_subgraph_index(&mut self, then_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  #[inline]
  pub fn add_else_subgraph_index(&mut self, else_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IfOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IfOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IfOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IfOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IfOptions");
      ds.field("then_subgraph_index", &self.then_subgraph_index());
      ds.field("else_subgraph_index", &self.else_subgraph_index());
      ds.finish()
  }
}
pub enum CallOnceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CallOnceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CallOnceOptions<'a> {
  type Inner = CallOnceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CallOnceOptions<'a> {
  pub const VT_INIT_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CallOnceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CallOnceOptionsArgs
  ) -> flatbuffers::WIPOffset<CallOnceOptions<'bldr>> {
    let mut builder = CallOnceOptionsBuilder::new(_fbb);
    builder.add_init_subgraph_index(args.init_subgraph_index);
    builder.finish()
  }


  #[inline]
  pub fn init_subgraph_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CallOnceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("init_subgraph_index", Self::VT_INIT_SUBGRAPH_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct CallOnceOptionsArgs {
    pub init_subgraph_index: i32,
}
impl<'a> Default for CallOnceOptionsArgs {
  #[inline]
  fn default() -> Self {
    CallOnceOptionsArgs {
      init_subgraph_index: 0,
    }
  }
}

pub struct CallOnceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallOnceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_init_subgraph_index(&mut self, init_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallOnceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallOnceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CallOnceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CallOnceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CallOnceOptions");
      ds.field("init_subgraph_index", &self.init_subgraph_index());
      ds.finish()
  }
}
pub enum WhileOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WhileOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WhileOptions<'a> {
  type Inner = WhileOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WhileOptions<'a> {
  pub const VT_COND_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_BODY_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WhileOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WhileOptionsArgs
  ) -> flatbuffers::WIPOffset<WhileOptions<'bldr>> {
    let mut builder = WhileOptionsBuilder::new(_fbb);
    builder.add_body_subgraph_index(args.body_subgraph_index);
    builder.add_cond_subgraph_index(args.cond_subgraph_index);
    builder.finish()
  }


  #[inline]
  pub fn cond_subgraph_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(WhileOptions::VT_COND_SUBGRAPH_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn body_subgraph_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for WhileOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("cond_subgraph_index", Self::VT_COND_SUBGRAPH_INDEX, false)?
     .visit_field::<i32>("body_subgraph_index", Self::VT_BODY_SUBGRAPH_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct WhileOptionsArgs {
    pub cond_subgraph_index: i32,
    pub body_subgraph_index: i32,
}
impl<'a> Default for WhileOptionsArgs {
  #[inline]
  fn default() -> Self {
    WhileOptionsArgs {
      cond_subgraph_index: 0,
      body_subgraph_index: 0,
    }
  }
}

pub struct WhileOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WhileOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_cond_subgraph_index(&mut self, cond_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  #[inline]
  pub fn add_body_subgraph_index(&mut self, body_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WhileOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WhileOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WhileOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WhileOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WhileOptions");
      ds.field("cond_subgraph_index", &self.cond_subgraph_index());
      ds.field("body_subgraph_index", &self.body_subgraph_index());
      ds.finish()
  }
}
pub enum NonMaxSuppressionV4OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NonMaxSuppressionV4Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionV4Options<'a> {
  type Inner = NonMaxSuppressionV4Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NonMaxSuppressionV4Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NonMaxSuppressionV4Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NonMaxSuppressionV4OptionsArgs
  ) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'bldr>> {
    let mut builder = NonMaxSuppressionV4OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for NonMaxSuppressionV4Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NonMaxSuppressionV4OptionsArgs {
}
impl<'a> Default for NonMaxSuppressionV4OptionsArgs {
  #[inline]
  fn default() -> Self {
    NonMaxSuppressionV4OptionsArgs {
    }
  }
}

pub struct NonMaxSuppressionV4OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NonMaxSuppressionV4OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NonMaxSuppressionV4OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NonMaxSuppressionV4OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NonMaxSuppressionV4Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NonMaxSuppressionV4Options");
      ds.finish()
  }
}
pub enum NonMaxSuppressionV5OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NonMaxSuppressionV5Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionV5Options<'a> {
  type Inner = NonMaxSuppressionV5Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NonMaxSuppressionV5Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NonMaxSuppressionV5Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NonMaxSuppressionV5OptionsArgs
  ) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'bldr>> {
    let mut builder = NonMaxSuppressionV5OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for NonMaxSuppressionV5Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NonMaxSuppressionV5OptionsArgs {
}
impl<'a> Default for NonMaxSuppressionV5OptionsArgs {
  #[inline]
  fn default() -> Self {
    NonMaxSuppressionV5OptionsArgs {
    }
  }
}

pub struct NonMaxSuppressionV5OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NonMaxSuppressionV5OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NonMaxSuppressionV5OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NonMaxSuppressionV5OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NonMaxSuppressionV5Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NonMaxSuppressionV5Options");
      ds.finish()
  }
}
pub enum ScatterNdOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScatterNdOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScatterNdOptions<'a> {
  type Inner = ScatterNdOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScatterNdOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScatterNdOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ScatterNdOptionsArgs
  ) -> flatbuffers::WIPOffset<ScatterNdOptions<'bldr>> {
    let mut builder = ScatterNdOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ScatterNdOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ScatterNdOptionsArgs {
}
impl<'a> Default for ScatterNdOptionsArgs {
  #[inline]
  fn default() -> Self {
    ScatterNdOptionsArgs {
    }
  }
}

pub struct ScatterNdOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScatterNdOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScatterNdOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScatterNdOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScatterNdOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScatterNdOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScatterNdOptions");
      ds.finish()
  }
}
pub enum SelectV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SelectV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SelectV2Options<'a> {
  type Inner = SelectV2Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SelectV2Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SelectV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SelectV2OptionsArgs
  ) -> flatbuffers::WIPOffset<SelectV2Options<'bldr>> {
    let mut builder = SelectV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SelectV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SelectV2OptionsArgs {
}
impl<'a> Default for SelectV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    SelectV2OptionsArgs {
    }
  }
}

pub struct SelectV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SelectV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SelectV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SelectV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SelectV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SelectV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SelectV2Options");
      ds.finish()
  }
}
pub enum DensifyOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DensifyOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DensifyOptions<'a> {
  type Inner = DensifyOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DensifyOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DensifyOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args DensifyOptionsArgs
  ) -> flatbuffers::WIPOffset<DensifyOptions<'bldr>> {
    let mut builder = DensifyOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for DensifyOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DensifyOptionsArgs {
}
impl<'a> Default for DensifyOptionsArgs {
  #[inline]
  fn default() -> Self {
    DensifyOptionsArgs {
    }
  }
}

pub struct DensifyOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DensifyOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DensifyOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DensifyOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DensifyOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DensifyOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DensifyOptions");
      ds.finish()
  }
}
pub enum SegmentSumOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SegmentSumOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SegmentSumOptions<'a> {
  type Inner = SegmentSumOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SegmentSumOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SegmentSumOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SegmentSumOptionsArgs
  ) -> flatbuffers::WIPOffset<SegmentSumOptions<'bldr>> {
    let mut builder = SegmentSumOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SegmentSumOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SegmentSumOptionsArgs {
}
impl<'a> Default for SegmentSumOptionsArgs {
  #[inline]
  fn default() -> Self {
    SegmentSumOptionsArgs {
    }
  }
}

pub struct SegmentSumOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SegmentSumOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SegmentSumOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SegmentSumOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SegmentSumOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SegmentSumOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SegmentSumOptions");
      ds.finish()
  }
}
pub enum BatchMatMulOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BatchMatMulOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchMatMulOptions<'a> {
  type Inner = BatchMatMulOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BatchMatMulOptions<'a> {
  pub const VT_ADJ_X: flatbuffers::VOffsetT = 4;
  pub const VT_ADJ_Y: flatbuffers::VOffsetT = 6;
  pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BatchMatMulOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BatchMatMulOptionsArgs
  ) -> flatbuffers::WIPOffset<BatchMatMulOptions<'bldr>> {
    let mut builder = BatchMatMulOptionsBuilder::new(_fbb);
    builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
    builder.add_adj_y(args.adj_y);
    builder.add_adj_x(args.adj_x);
    builder.finish()
  }


  #[inline]
  pub fn adj_x(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BatchMatMulOptions::VT_ADJ_X, Some(false)).unwrap()}
  }
  #[inline]
  pub fn adj_y(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BatchMatMulOptions::VT_ADJ_Y, Some(false)).unwrap()}
  }
  #[inline]
  pub fn asymmetric_quantize_inputs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BatchMatMulOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("adj_x", Self::VT_ADJ_X, false)?
     .visit_field::<bool>("adj_y", Self::VT_ADJ_Y, false)?
     .visit_field::<bool>("asymmetric_quantize_inputs", Self::VT_ASYMMETRIC_QUANTIZE_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BatchMatMulOptionsArgs {
    pub adj_x: bool,
    pub adj_y: bool,
    pub asymmetric_quantize_inputs: bool,
}
impl<'a> Default for BatchMatMulOptionsArgs {
  #[inline]
  fn default() -> Self {
    BatchMatMulOptionsArgs {
      adj_x: false,
      adj_y: false,
      asymmetric_quantize_inputs: false,
    }
  }
}

pub struct BatchMatMulOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BatchMatMulOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_adj_x(&mut self, adj_x: bool) {
    self.fbb_.push_slot::<bool>(BatchMatMulOptions::VT_ADJ_X, adj_x, false);
  }
  #[inline]
  pub fn add_adj_y(&mut self, adj_y: bool) {
    self.fbb_.push_slot::<bool>(BatchMatMulOptions::VT_ADJ_Y, adj_y, false);
  }
  #[inline]
  pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
    self.fbb_.push_slot::<bool>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, asymmetric_quantize_inputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BatchMatMulOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BatchMatMulOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BatchMatMulOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BatchMatMulOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BatchMatMulOptions");
      ds.field("adj_x", &self.adj_x());
      ds.field("adj_y", &self.adj_y());
      ds.field("asymmetric_quantize_inputs", &self.asymmetric_quantize_inputs());
      ds.finish()
  }
}
pub enum CumsumOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CumsumOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CumsumOptions<'a> {
  type Inner = CumsumOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CumsumOptions<'a> {
  pub const VT_EXCLUSIVE: flatbuffers::VOffsetT = 4;
  pub const VT_REVERSE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CumsumOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CumsumOptionsArgs
  ) -> flatbuffers::WIPOffset<CumsumOptions<'bldr>> {
    let mut builder = CumsumOptionsBuilder::new(_fbb);
    builder.add_reverse(args.reverse);
    builder.add_exclusive(args.exclusive);
    builder.finish()
  }


  #[inline]
  pub fn exclusive(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CumsumOptions::VT_EXCLUSIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn reverse(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CumsumOptions::VT_REVERSE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CumsumOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("exclusive", Self::VT_EXCLUSIVE, false)?
     .visit_field::<bool>("reverse", Self::VT_REVERSE, false)?
     .finish();
    Ok(())
  }
}
pub struct CumsumOptionsArgs {
    pub exclusive: bool,
    pub reverse: bool,
}
impl<'a> Default for CumsumOptionsArgs {
  #[inline]
  fn default() -> Self {
    CumsumOptionsArgs {
      exclusive: false,
      reverse: false,
    }
  }
}

pub struct CumsumOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CumsumOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_exclusive(&mut self, exclusive: bool) {
    self.fbb_.push_slot::<bool>(CumsumOptions::VT_EXCLUSIVE, exclusive, false);
  }
  #[inline]
  pub fn add_reverse(&mut self, reverse: bool) {
    self.fbb_.push_slot::<bool>(CumsumOptions::VT_REVERSE, reverse, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CumsumOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CumsumOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CumsumOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CumsumOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CumsumOptions");
      ds.field("exclusive", &self.exclusive());
      ds.field("reverse", &self.reverse());
      ds.finish()
  }
}
pub enum BroadcastToOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BroadcastToOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BroadcastToOptions<'a> {
  type Inner = BroadcastToOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BroadcastToOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BroadcastToOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args BroadcastToOptionsArgs
  ) -> flatbuffers::WIPOffset<BroadcastToOptions<'bldr>> {
    let mut builder = BroadcastToOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for BroadcastToOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct BroadcastToOptionsArgs {
}
impl<'a> Default for BroadcastToOptionsArgs {
  #[inline]
  fn default() -> Self {
    BroadcastToOptionsArgs {
    }
  }
}

pub struct BroadcastToOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BroadcastToOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BroadcastToOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BroadcastToOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastToOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BroadcastToOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BroadcastToOptions");
      ds.finish()
  }
}
pub enum Rfft2dOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rfft2dOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rfft2dOptions<'a> {
  type Inner = Rfft2dOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Rfft2dOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rfft2dOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args Rfft2dOptionsArgs
  ) -> flatbuffers::WIPOffset<Rfft2dOptions<'bldr>> {
    let mut builder = Rfft2dOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Rfft2dOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct Rfft2dOptionsArgs {
}
impl<'a> Default for Rfft2dOptionsArgs {
  #[inline]
  fn default() -> Self {
    Rfft2dOptionsArgs {
    }
  }
}

pub struct Rfft2dOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Rfft2dOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Rfft2dOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Rfft2dOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rfft2dOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rfft2dOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rfft2dOptions");
      ds.finish()
  }
}
pub enum HashtableOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashtableOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HashtableOptions<'a> {
  type Inner = HashtableOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HashtableOptions<'a> {
  pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_KEY_DTYPE: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE_DTYPE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HashtableOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HashtableOptionsArgs
  ) -> flatbuffers::WIPOffset<HashtableOptions<'bldr>> {
    let mut builder = HashtableOptionsBuilder::new(_fbb);
    builder.add_table_id(args.table_id);
    builder.add_value_dtype(args.value_dtype);
    builder.add_key_dtype(args.key_dtype);
    builder.finish()
  }


  #[inline]
  pub fn table_id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(HashtableOptions::VT_TABLE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_dtype(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(HashtableOptions::VT_KEY_DTYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
  #[inline]
  pub fn value_dtype(&self) -> TensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorType>(HashtableOptions::VT_VALUE_DTYPE, Some(TensorType::FLOAT32)).unwrap()}
  }
}

impl flatbuffers::Verifiable for HashtableOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("table_id", Self::VT_TABLE_ID, false)?
     .visit_field::<TensorType>("key_dtype", Self::VT_KEY_DTYPE, false)?
     .visit_field::<TensorType>("value_dtype", Self::VT_VALUE_DTYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct HashtableOptionsArgs {
    pub table_id: i32,
    pub key_dtype: TensorType,
    pub value_dtype: TensorType,
}
impl<'a> Default for HashtableOptionsArgs {
  #[inline]
  fn default() -> Self {
    HashtableOptionsArgs {
      table_id: 0,
      key_dtype: TensorType::FLOAT32,
      value_dtype: TensorType::FLOAT32,
    }
  }
}

pub struct HashtableOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HashtableOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_table_id(&mut self, table_id: i32) {
    self.fbb_.push_slot::<i32>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  #[inline]
  pub fn add_key_dtype(&mut self, key_dtype: TensorType) {
    self.fbb_.push_slot::<TensorType>(HashtableOptions::VT_KEY_DTYPE, key_dtype, TensorType::FLOAT32);
  }
  #[inline]
  pub fn add_value_dtype(&mut self, value_dtype: TensorType) {
    self.fbb_.push_slot::<TensorType>(HashtableOptions::VT_VALUE_DTYPE, value_dtype, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HashtableOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HashtableOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HashtableOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HashtableOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HashtableOptions");
      ds.field("table_id", &self.table_id());
      ds.field("key_dtype", &self.key_dtype());
      ds.field("value_dtype", &self.value_dtype());
      ds.finish()
  }
}
pub enum HashtableFindOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashtableFindOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HashtableFindOptions<'a> {
  type Inner = HashtableFindOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HashtableFindOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HashtableFindOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HashtableFindOptionsArgs
  ) -> flatbuffers::WIPOffset<HashtableFindOptions<'bldr>> {
    let mut builder = HashtableFindOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for HashtableFindOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HashtableFindOptionsArgs {
}
impl<'a> Default for HashtableFindOptionsArgs {
  #[inline]
  fn default() -> Self {
    HashtableFindOptionsArgs {
    }
  }
}

pub struct HashtableFindOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HashtableFindOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HashtableFindOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HashtableFindOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HashtableFindOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HashtableFindOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HashtableFindOptions");
      ds.finish()
  }
}
pub enum HashtableImportOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashtableImportOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HashtableImportOptions<'a> {
  type Inner = HashtableImportOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HashtableImportOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HashtableImportOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HashtableImportOptionsArgs
  ) -> flatbuffers::WIPOffset<HashtableImportOptions<'bldr>> {
    let mut builder = HashtableImportOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for HashtableImportOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HashtableImportOptionsArgs {
}
impl<'a> Default for HashtableImportOptionsArgs {
  #[inline]
  fn default() -> Self {
    HashtableImportOptionsArgs {
    }
  }
}

pub struct HashtableImportOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HashtableImportOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HashtableImportOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HashtableImportOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HashtableImportOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HashtableImportOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HashtableImportOptions");
      ds.finish()
  }
}
pub enum HashtableSizeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashtableSizeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HashtableSizeOptions<'a> {
  type Inner = HashtableSizeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HashtableSizeOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HashtableSizeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HashtableSizeOptionsArgs
  ) -> flatbuffers::WIPOffset<HashtableSizeOptions<'bldr>> {
    let mut builder = HashtableSizeOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for HashtableSizeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HashtableSizeOptionsArgs {
}
impl<'a> Default for HashtableSizeOptionsArgs {
  #[inline]
  fn default() -> Self {
    HashtableSizeOptionsArgs {
    }
  }
}

pub struct HashtableSizeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HashtableSizeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HashtableSizeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HashtableSizeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HashtableSizeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HashtableSizeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HashtableSizeOptions");
      ds.finish()
  }
}
pub enum VarHandleOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VarHandleOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VarHandleOptions<'a> {
  type Inner = VarHandleOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VarHandleOptions<'a> {
  pub const VT_CONTAINER: flatbuffers::VOffsetT = 4;
  pub const VT_SHARED_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VarHandleOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VarHandleOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<VarHandleOptions<'bldr>> {
    let mut builder = VarHandleOptionsBuilder::new(_fbb);
    if let Some(x) = args.shared_name { builder.add_shared_name(x); }
    if let Some(x) = args.container { builder.add_container(x); }
    builder.finish()
  }


  #[inline]
  pub fn container(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VarHandleOptions::VT_CONTAINER, None)}
  }
  #[inline]
  pub fn shared_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VarHandleOptions::VT_SHARED_NAME, None)}
  }
}

impl flatbuffers::Verifiable for VarHandleOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("container", Self::VT_CONTAINER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shared_name", Self::VT_SHARED_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct VarHandleOptionsArgs<'a> {
    pub container: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shared_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for VarHandleOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    VarHandleOptionsArgs {
      container: None,
      shared_name: None,
    }
  }
}

pub struct VarHandleOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VarHandleOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_container(&mut self, container: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VarHandleOptions::VT_CONTAINER, container);
  }
  #[inline]
  pub fn add_shared_name(&mut self, shared_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VarHandleOptions::VT_SHARED_NAME, shared_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VarHandleOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VarHandleOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VarHandleOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VarHandleOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VarHandleOptions");
      ds.field("container", &self.container());
      ds.field("shared_name", &self.shared_name());
      ds.finish()
  }
}
pub enum ReadVariableOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadVariableOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadVariableOptions<'a> {
  type Inner = ReadVariableOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReadVariableOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadVariableOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ReadVariableOptionsArgs
  ) -> flatbuffers::WIPOffset<ReadVariableOptions<'bldr>> {
    let mut builder = ReadVariableOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ReadVariableOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReadVariableOptionsArgs {
}
impl<'a> Default for ReadVariableOptionsArgs {
  #[inline]
  fn default() -> Self {
    ReadVariableOptionsArgs {
    }
  }
}

pub struct ReadVariableOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadVariableOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadVariableOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadVariableOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadVariableOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReadVariableOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReadVariableOptions");
      ds.finish()
  }
}
pub enum AssignVariableOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AssignVariableOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssignVariableOptions<'a> {
  type Inner = AssignVariableOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AssignVariableOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AssignVariableOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AssignVariableOptionsArgs
  ) -> flatbuffers::WIPOffset<AssignVariableOptions<'bldr>> {
    let mut builder = AssignVariableOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AssignVariableOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AssignVariableOptionsArgs {
}
impl<'a> Default for AssignVariableOptionsArgs {
  #[inline]
  fn default() -> Self {
    AssignVariableOptionsArgs {
    }
  }
}

pub struct AssignVariableOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignVariableOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignVariableOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignVariableOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssignVariableOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AssignVariableOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AssignVariableOptions");
      ds.finish()
  }
}
pub enum RandomOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RandomOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RandomOptions<'a> {
  type Inner = RandomOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RandomOptions<'a> {
  pub const VT_SEED: flatbuffers::VOffsetT = 4;
  pub const VT_SEED2: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RandomOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RandomOptionsArgs
  ) -> flatbuffers::WIPOffset<RandomOptions<'bldr>> {
    let mut builder = RandomOptionsBuilder::new(_fbb);
    builder.add_seed2(args.seed2);
    builder.add_seed(args.seed);
    builder.finish()
  }


  #[inline]
  pub fn seed(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RandomOptions::VT_SEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn seed2(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RandomOptions::VT_SEED2, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RandomOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("seed", Self::VT_SEED, false)?
     .visit_field::<i64>("seed2", Self::VT_SEED2, false)?
     .finish();
    Ok(())
  }
}
pub struct RandomOptionsArgs {
    pub seed: i64,
    pub seed2: i64,
}
impl<'a> Default for RandomOptionsArgs {
  #[inline]
  fn default() -> Self {
    RandomOptionsArgs {
      seed: 0,
      seed2: 0,
    }
  }
}

pub struct RandomOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RandomOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_seed(&mut self, seed: i64) {
    self.fbb_.push_slot::<i64>(RandomOptions::VT_SEED, seed, 0);
  }
  #[inline]
  pub fn add_seed2(&mut self, seed2: i64) {
    self.fbb_.push_slot::<i64>(RandomOptions::VT_SEED2, seed2, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RandomOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RandomOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RandomOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RandomOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RandomOptions");
      ds.field("seed", &self.seed());
      ds.field("seed2", &self.seed2());
      ds.finish()
  }
}
pub enum BucketizeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BucketizeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BucketizeOptions<'a> {
  type Inner = BucketizeOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BucketizeOptions<'a> {
  pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BucketizeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BucketizeOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<BucketizeOptions<'bldr>> {
    let mut builder = BucketizeOptionsBuilder::new(_fbb);
    if let Some(x) = args.boundaries { builder.add_boundaries(x); }
    builder.finish()
  }


  #[inline]
  pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(BucketizeOptions::VT_BOUNDARIES, None)}
  }
}

impl flatbuffers::Verifiable for BucketizeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("boundaries", Self::VT_BOUNDARIES, false)?
     .finish();
    Ok(())
  }
}
pub struct BucketizeOptionsArgs<'a> {
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for BucketizeOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    BucketizeOptionsArgs {
      boundaries: None,
    }
  }
}

pub struct BucketizeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BucketizeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_boundaries(&mut self, boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BucketizeOptions::VT_BOUNDARIES, boundaries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BucketizeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BucketizeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BucketizeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BucketizeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BucketizeOptions");
      ds.field("boundaries", &self.boundaries());
      ds.finish()
  }
}
pub enum GeluOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GeluOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GeluOptions<'a> {
  type Inner = GeluOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GeluOptions<'a> {
  pub const VT_APPROXIMATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GeluOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GeluOptionsArgs
  ) -> flatbuffers::WIPOffset<GeluOptions<'bldr>> {
    let mut builder = GeluOptionsBuilder::new(_fbb);
    builder.add_approximate(args.approximate);
    builder.finish()
  }


  #[inline]
  pub fn approximate(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GeluOptions::VT_APPROXIMATE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GeluOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("approximate", Self::VT_APPROXIMATE, false)?
     .finish();
    Ok(())
  }
}
pub struct GeluOptionsArgs {
    pub approximate: bool,
}
impl<'a> Default for GeluOptionsArgs {
  #[inline]
  fn default() -> Self {
    GeluOptionsArgs {
      approximate: false,
    }
  }
}

pub struct GeluOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GeluOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_approximate(&mut self, approximate: bool) {
    self.fbb_.push_slot::<bool>(GeluOptions::VT_APPROXIMATE, approximate, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GeluOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GeluOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GeluOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GeluOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GeluOptions");
      ds.field("approximate", &self.approximate());
      ds.finish()
  }
}
pub enum DynamicUpdateSliceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DynamicUpdateSliceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DynamicUpdateSliceOptions<'a> {
  type Inner = DynamicUpdateSliceOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DynamicUpdateSliceOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DynamicUpdateSliceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args DynamicUpdateSliceOptionsArgs
  ) -> flatbuffers::WIPOffset<DynamicUpdateSliceOptions<'bldr>> {
    let mut builder = DynamicUpdateSliceOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for DynamicUpdateSliceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DynamicUpdateSliceOptionsArgs {
}
impl<'a> Default for DynamicUpdateSliceOptionsArgs {
  #[inline]
  fn default() -> Self {
    DynamicUpdateSliceOptionsArgs {
    }
  }
}

pub struct DynamicUpdateSliceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DynamicUpdateSliceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DynamicUpdateSliceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DynamicUpdateSliceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DynamicUpdateSliceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DynamicUpdateSliceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DynamicUpdateSliceOptions");
      ds.finish()
  }
}
pub enum UnsortedSegmentProdOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnsortedSegmentProdOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentProdOptions<'a> {
  type Inner = UnsortedSegmentProdOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnsortedSegmentProdOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnsortedSegmentProdOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args UnsortedSegmentProdOptionsArgs
  ) -> flatbuffers::WIPOffset<UnsortedSegmentProdOptions<'bldr>> {
    let mut builder = UnsortedSegmentProdOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for UnsortedSegmentProdOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct UnsortedSegmentProdOptionsArgs {
}
impl<'a> Default for UnsortedSegmentProdOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnsortedSegmentProdOptionsArgs {
    }
  }
}

pub struct UnsortedSegmentProdOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsortedSegmentProdOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsortedSegmentProdOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsortedSegmentProdOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentProdOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnsortedSegmentProdOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnsortedSegmentProdOptions");
      ds.finish()
  }
}
pub enum UnsortedSegmentMaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnsortedSegmentMaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentMaxOptions<'a> {
  type Inner = UnsortedSegmentMaxOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnsortedSegmentMaxOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnsortedSegmentMaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args UnsortedSegmentMaxOptionsArgs
  ) -> flatbuffers::WIPOffset<UnsortedSegmentMaxOptions<'bldr>> {
    let mut builder = UnsortedSegmentMaxOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for UnsortedSegmentMaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct UnsortedSegmentMaxOptionsArgs {
}
impl<'a> Default for UnsortedSegmentMaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnsortedSegmentMaxOptionsArgs {
    }
  }
}

pub struct UnsortedSegmentMaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsortedSegmentMaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsortedSegmentMaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsortedSegmentMaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentMaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnsortedSegmentMaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnsortedSegmentMaxOptions");
      ds.finish()
  }
}
pub enum UnsortedSegmentSumOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnsortedSegmentSumOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentSumOptions<'a> {
  type Inner = UnsortedSegmentSumOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnsortedSegmentSumOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnsortedSegmentSumOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args UnsortedSegmentSumOptionsArgs
  ) -> flatbuffers::WIPOffset<UnsortedSegmentSumOptions<'bldr>> {
    let mut builder = UnsortedSegmentSumOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for UnsortedSegmentSumOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct UnsortedSegmentSumOptionsArgs {
}
impl<'a> Default for UnsortedSegmentSumOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnsortedSegmentSumOptionsArgs {
    }
  }
}

pub struct UnsortedSegmentSumOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsortedSegmentSumOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsortedSegmentSumOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsortedSegmentSumOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentSumOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnsortedSegmentSumOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnsortedSegmentSumOptions");
      ds.finish()
  }
}
pub enum ATan2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ATan2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ATan2Options<'a> {
  type Inner = ATan2Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ATan2Options<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ATan2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ATan2OptionsArgs
  ) -> flatbuffers::WIPOffset<ATan2Options<'bldr>> {
    let mut builder = ATan2OptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ATan2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ATan2OptionsArgs {
}
impl<'a> Default for ATan2OptionsArgs {
  #[inline]
  fn default() -> Self {
    ATan2OptionsArgs {
    }
  }
}

pub struct ATan2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ATan2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ATan2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ATan2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ATan2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ATan2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ATan2Options");
      ds.finish()
  }
}
pub enum UnsortedSegmentMinOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnsortedSegmentMinOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentMinOptions<'a> {
  type Inner = UnsortedSegmentMinOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnsortedSegmentMinOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnsortedSegmentMinOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args UnsortedSegmentMinOptionsArgs
  ) -> flatbuffers::WIPOffset<UnsortedSegmentMinOptions<'bldr>> {
    let mut builder = UnsortedSegmentMinOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for UnsortedSegmentMinOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct UnsortedSegmentMinOptionsArgs {
}
impl<'a> Default for UnsortedSegmentMinOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnsortedSegmentMinOptionsArgs {
    }
  }
}

pub struct UnsortedSegmentMinOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsortedSegmentMinOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsortedSegmentMinOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsortedSegmentMinOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentMinOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnsortedSegmentMinOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnsortedSegmentMinOptions");
      ds.finish()
  }
}
pub enum SignOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignOptions<'a> {
  type Inner = SignOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SignOptionsArgs
  ) -> flatbuffers::WIPOffset<SignOptions<'bldr>> {
    let mut builder = SignOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SignOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SignOptionsArgs {
}
impl<'a> Default for SignOptionsArgs {
  #[inline]
  fn default() -> Self {
    SignOptionsArgs {
    }
  }
}

pub struct SignOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SignOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SignOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignOptions");
      ds.finish()
  }
}
pub enum BitcastOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BitcastOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BitcastOptions<'a> {
  type Inner = BitcastOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BitcastOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BitcastOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args BitcastOptionsArgs
  ) -> flatbuffers::WIPOffset<BitcastOptions<'bldr>> {
    let mut builder = BitcastOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for BitcastOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct BitcastOptionsArgs {
}
impl<'a> Default for BitcastOptionsArgs {
  #[inline]
  fn default() -> Self {
    BitcastOptionsArgs {
    }
  }
}

pub struct BitcastOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BitcastOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BitcastOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BitcastOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BitcastOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BitcastOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BitcastOptions");
      ds.finish()
  }
}
pub enum BitwiseXorOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BitwiseXorOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BitwiseXorOptions<'a> {
  type Inner = BitwiseXorOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BitwiseXorOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BitwiseXorOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args BitwiseXorOptionsArgs
  ) -> flatbuffers::WIPOffset<BitwiseXorOptions<'bldr>> {
    let mut builder = BitwiseXorOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for BitwiseXorOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct BitwiseXorOptionsArgs {
}
impl<'a> Default for BitwiseXorOptionsArgs {
  #[inline]
  fn default() -> Self {
    BitwiseXorOptionsArgs {
    }
  }
}

pub struct BitwiseXorOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BitwiseXorOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BitwiseXorOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BitwiseXorOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BitwiseXorOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BitwiseXorOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BitwiseXorOptions");
      ds.finish()
  }
}
pub enum RightShiftOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RightShiftOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RightShiftOptions<'a> {
  type Inner = RightShiftOptions<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RightShiftOptions<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RightShiftOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RightShiftOptionsArgs
  ) -> flatbuffers::WIPOffset<RightShiftOptions<'bldr>> {
    let mut builder = RightShiftOptionsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for RightShiftOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RightShiftOptionsArgs {
}
impl<'a> Default for RightShiftOptionsArgs {
  #[inline]
  fn default() -> Self {
    RightShiftOptionsArgs {
    }
  }
}

pub struct RightShiftOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RightShiftOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RightShiftOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RightShiftOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RightShiftOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RightShiftOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RightShiftOptions");
      ds.finish()
  }
}
pub enum OperatorCodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorCode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorCode<'a> {
  type Inner = OperatorCode<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OperatorCode<'a> {
  pub const VT_DEPRECATED_BUILTIN_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_CUSTOM_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_VERSION: flatbuffers::VOffsetT = 8;
  pub const VT_BUILTIN_CODE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OperatorCode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OperatorCodeArgs<'args>
  ) -> flatbuffers::WIPOffset<OperatorCode<'bldr>> {
    let mut builder = OperatorCodeBuilder::new(_fbb);
    builder.add_builtin_code(args.builtin_code);
    builder.add_version(args.version);
    if let Some(x) = args.custom_code { builder.add_custom_code(x); }
    builder.add_deprecated_builtin_code(args.deprecated_builtin_code);
    builder.finish()
  }


  #[inline]
  pub fn deprecated_builtin_code(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn custom_code(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorCode::VT_CUSTOM_CODE, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OperatorCode::VT_VERSION, Some(1)).unwrap()}
  }
  #[inline]
  pub fn builtin_code(&self) -> BuiltinOperator {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BuiltinOperator>(OperatorCode::VT_BUILTIN_CODE, Some(BuiltinOperator::ADD)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OperatorCode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("deprecated_builtin_code", Self::VT_DEPRECATED_BUILTIN_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("custom_code", Self::VT_CUSTOM_CODE, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<BuiltinOperator>("builtin_code", Self::VT_BUILTIN_CODE, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorCodeArgs<'a> {
    pub deprecated_builtin_code: i8,
    pub custom_code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub builtin_code: BuiltinOperator,
}
impl<'a> Default for OperatorCodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorCodeArgs {
      deprecated_builtin_code: 0,
      custom_code: None,
      version: 1,
      builtin_code: BuiltinOperator::ADD,
    }
  }
}

pub struct OperatorCodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorCodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_deprecated_builtin_code(&mut self, deprecated_builtin_code: i8) {
    self.fbb_.push_slot::<i8>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);
  }
  #[inline]
  pub fn add_custom_code(&mut self, custom_code: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(OperatorCode::VT_VERSION, version, 1);
  }
  #[inline]
  pub fn add_builtin_code(&mut self, builtin_code: BuiltinOperator) {
    self.fbb_.push_slot::<BuiltinOperator>(OperatorCode::VT_BUILTIN_CODE, builtin_code, BuiltinOperator::ADD);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorCodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperatorCodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OperatorCode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OperatorCode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OperatorCode");
      ds.field("deprecated_builtin_code", &self.deprecated_builtin_code());
      ds.field("custom_code", &self.custom_code());
      ds.field("version", &self.version());
      ds.field("builtin_code", &self.builtin_code());
      ds.finish()
  }
}
pub enum OperatorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Operator<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operator<'a> {
  type Inner = Operator<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Operator<'a> {
  pub const VT_OPCODE_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
  pub const VT_BUILTIN_OPTIONS_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_BUILTIN_OPTIONS: flatbuffers::VOffsetT = 12;
  pub const VT_CUSTOM_OPTIONS: flatbuffers::VOffsetT = 14;
  pub const VT_CUSTOM_OPTIONS_FORMAT: flatbuffers::VOffsetT = 16;
  pub const VT_MUTATING_VARIABLE_INPUTS: flatbuffers::VOffsetT = 18;
  pub const VT_INTERMEDIATES: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Operator { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OperatorArgs<'args>
  ) -> flatbuffers::WIPOffset<Operator<'bldr>> {
    let mut builder = OperatorBuilder::new(_fbb);
    if let Some(x) = args.intermediates { builder.add_intermediates(x); }
    if let Some(x) = args.mutating_variable_inputs { builder.add_mutating_variable_inputs(x); }
    if let Some(x) = args.custom_options { builder.add_custom_options(x); }
    if let Some(x) = args.builtin_options { builder.add_builtin_options(x); }
    if let Some(x) = args.outputs { builder.add_outputs(x); }
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    builder.add_opcode_index(args.opcode_index);
    builder.add_custom_options_format(args.custom_options_format);
    builder.add_builtin_options_type(args.builtin_options_type);
    builder.finish()
  }


  #[inline]
  pub fn opcode_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Operator::VT_OPCODE_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Operator::VT_INPUTS, None)}
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Operator::VT_OUTPUTS, None)}
  }
  #[inline]
  pub fn builtin_options_type(&self) -> BuiltinOptions {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BuiltinOptions>(Operator::VT_BUILTIN_OPTIONS_TYPE, Some(BuiltinOptions::NONE)).unwrap()}
  }
  #[inline]
  pub fn builtin_options(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Operator::VT_BUILTIN_OPTIONS, None)}
  }
  #[inline]
  pub fn custom_options(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Operator::VT_CUSTOM_OPTIONS, None)}
  }
  #[inline]
  pub fn custom_options_format(&self) -> CustomOptionsFormat {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CustomOptionsFormat>(Operator::VT_CUSTOM_OPTIONS_FORMAT, Some(CustomOptionsFormat::FLEXBUFFERS)).unwrap()}
  }
  #[inline]
  pub fn mutating_variable_inputs(&self) -> Option<flatbuffers::Vector<'a, bool>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(Operator::VT_MUTATING_VARIABLE_INPUTS, None)}
  }
  #[inline]
  pub fn intermediates(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Operator::VT_INTERMEDIATES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_conv_2_doptions(&self) -> Option<Conv2DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::Conv2DOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Conv2DOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_depthwise_conv_2_doptions(&self) -> Option<DepthwiseConv2DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DepthwiseConv2DOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DepthwiseConv2DOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_concat_embeddings_options(&self) -> Option<ConcatEmbeddingsOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ConcatEmbeddingsOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConcatEmbeddingsOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_lshprojection_options(&self) -> Option<LSHProjectionOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LSHProjectionOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LSHProjectionOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pool_2_doptions(&self) -> Option<Pool2DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::Pool2DOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Pool2DOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_svdfoptions(&self) -> Option<SVDFOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SVDFOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SVDFOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_rnnoptions(&self) -> Option<RNNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RNNOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RNNOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_fully_connected_options(&self) -> Option<FullyConnectedOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FullyConnectedOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FullyConnectedOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_softmax_options(&self) -> Option<SoftmaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SoftmaxOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SoftmaxOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_concatenation_options(&self) -> Option<ConcatenationOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ConcatenationOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConcatenationOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_add_options(&self) -> Option<AddOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AddOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AddOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_l2_norm_options(&self) -> Option<L2NormOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::L2NormOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { L2NormOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_local_response_normalization_options(&self) -> Option<LocalResponseNormalizationOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LocalResponseNormalizationOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LocalResponseNormalizationOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_lstmoptions(&self) -> Option<LSTMOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LSTMOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LSTMOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_resize_bilinear_options(&self) -> Option<ResizeBilinearOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ResizeBilinearOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ResizeBilinearOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_call_options(&self) -> Option<CallOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CallOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CallOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reshape_options(&self) -> Option<ReshapeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReshapeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReshapeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_skip_gram_options(&self) -> Option<SkipGramOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SkipGramOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SkipGramOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_space_to_depth_options(&self) -> Option<SpaceToDepthOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SpaceToDepthOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SpaceToDepthOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_embedding_lookup_sparse_options(&self) -> Option<EmbeddingLookupSparseOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::EmbeddingLookupSparseOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EmbeddingLookupSparseOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_mul_options(&self) -> Option<MulOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MulOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MulOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pad_options(&self) -> Option<PadOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PadOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PadOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_gather_options(&self) -> Option<GatherOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GatherOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GatherOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_batch_to_space_ndoptions(&self) -> Option<BatchToSpaceNDOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BatchToSpaceNDOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BatchToSpaceNDOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_space_to_batch_ndoptions(&self) -> Option<SpaceToBatchNDOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SpaceToBatchNDOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SpaceToBatchNDOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_transpose_options(&self) -> Option<TransposeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TransposeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TransposeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reducer_options(&self) -> Option<ReducerOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReducerOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReducerOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sub_options(&self) -> Option<SubOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SubOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SubOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_div_options(&self) -> Option<DivOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DivOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DivOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_squeeze_options(&self) -> Option<SqueezeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SqueezeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SqueezeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sequence_rnnoptions(&self) -> Option<SequenceRNNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SequenceRNNOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SequenceRNNOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_strided_slice_options(&self) -> Option<StridedSliceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::StridedSliceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StridedSliceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_exp_options(&self) -> Option<ExpOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ExpOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ExpOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_top_kv2_options(&self) -> Option<TopKV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TopKV2Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TopKV2Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_split_options(&self) -> Option<SplitOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SplitOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SplitOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_log_softmax_options(&self) -> Option<LogSoftmaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogSoftmaxOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LogSoftmaxOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_cast_options(&self) -> Option<CastOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CastOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CastOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_dequantize_options(&self) -> Option<DequantizeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DequantizeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DequantizeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_maximum_minimum_options(&self) -> Option<MaximumMinimumOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MaximumMinimumOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MaximumMinimumOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_arg_max_options(&self) -> Option<ArgMaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ArgMaxOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ArgMaxOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_less_options(&self) -> Option<LessOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LessOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LessOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_neg_options(&self) -> Option<NegOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NegOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NegOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pad_v2_options(&self) -> Option<PadV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PadV2Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PadV2Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_greater_options(&self) -> Option<GreaterOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GreaterOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GreaterOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_greater_equal_options(&self) -> Option<GreaterEqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GreaterEqualOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GreaterEqualOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_less_equal_options(&self) -> Option<LessEqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LessEqualOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LessEqualOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_select_options(&self) -> Option<SelectOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SelectOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SelectOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_slice_options(&self) -> Option<SliceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SliceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SliceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_transpose_conv_options(&self) -> Option<TransposeConvOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TransposeConvOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TransposeConvOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sparse_to_dense_options(&self) -> Option<SparseToDenseOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SparseToDenseOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SparseToDenseOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_tile_options(&self) -> Option<TileOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TileOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TileOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_expand_dims_options(&self) -> Option<ExpandDimsOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ExpandDimsOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ExpandDimsOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_equal_options(&self) -> Option<EqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::EqualOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EqualOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_not_equal_options(&self) -> Option<NotEqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NotEqualOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NotEqualOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_shape_options(&self) -> Option<ShapeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ShapeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ShapeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pow_options(&self) -> Option<PowOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PowOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PowOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_arg_min_options(&self) -> Option<ArgMinOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ArgMinOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ArgMinOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_fake_quant_options(&self) -> Option<FakeQuantOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FakeQuantOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FakeQuantOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pack_options(&self) -> Option<PackOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PackOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PackOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_logical_or_options(&self) -> Option<LogicalOrOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogicalOrOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LogicalOrOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_one_hot_options(&self) -> Option<OneHotOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::OneHotOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OneHotOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_logical_and_options(&self) -> Option<LogicalAndOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogicalAndOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LogicalAndOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_logical_not_options(&self) -> Option<LogicalNotOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogicalNotOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LogicalNotOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unpack_options(&self) -> Option<UnpackOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnpackOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnpackOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_floor_div_options(&self) -> Option<FloorDivOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FloorDivOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FloorDivOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_square_options(&self) -> Option<SquareOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SquareOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SquareOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_zeros_like_options(&self) -> Option<ZerosLikeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ZerosLikeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ZerosLikeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_fill_options(&self) -> Option<FillOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FillOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FillOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bidirectional_sequence_lstmoptions(&self) -> Option<BidirectionalSequenceLSTMOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BidirectionalSequenceLSTMOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BidirectionalSequenceLSTMOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bidirectional_sequence_rnnoptions(&self) -> Option<BidirectionalSequenceRNNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BidirectionalSequenceRNNOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BidirectionalSequenceRNNOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unidirectional_sequence_lstmoptions(&self) -> Option<UnidirectionalSequenceLSTMOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnidirectionalSequenceLSTMOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnidirectionalSequenceLSTMOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_floor_mod_options(&self) -> Option<FloorModOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FloorModOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FloorModOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_range_options(&self) -> Option<RangeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RangeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RangeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_resize_nearest_neighbor_options(&self) -> Option<ResizeNearestNeighborOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ResizeNearestNeighborOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ResizeNearestNeighborOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_leaky_relu_options(&self) -> Option<LeakyReluOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LeakyReluOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LeakyReluOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_squared_difference_options(&self) -> Option<SquaredDifferenceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SquaredDifferenceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SquaredDifferenceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_mirror_pad_options(&self) -> Option<MirrorPadOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MirrorPadOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MirrorPadOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_abs_options(&self) -> Option<AbsOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AbsOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AbsOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_split_voptions(&self) -> Option<SplitVOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SplitVOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SplitVOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unique_options(&self) -> Option<UniqueOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UniqueOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UniqueOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reverse_v2_options(&self) -> Option<ReverseV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReverseV2Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReverseV2Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_add_noptions(&self) -> Option<AddNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AddNOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AddNOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_gather_nd_options(&self) -> Option<GatherNdOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GatherNdOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GatherNdOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_cos_options(&self) -> Option<CosOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CosOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CosOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_where_options(&self) -> Option<WhereOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::WhereOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { WhereOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_rank_options(&self) -> Option<RankOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RankOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RankOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reverse_sequence_options(&self) -> Option<ReverseSequenceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReverseSequenceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReverseSequenceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_matrix_diag_options(&self) -> Option<MatrixDiagOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MatrixDiagOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MatrixDiagOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_quantize_options(&self) -> Option<QuantizeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::QuantizeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QuantizeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_matrix_set_diag_options(&self) -> Option<MatrixSetDiagOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MatrixSetDiagOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MatrixSetDiagOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_hard_swish_options(&self) -> Option<HardSwishOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::HardSwishOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HardSwishOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_if_options(&self) -> Option<IfOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::IfOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { IfOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_while_options(&self) -> Option<WhileOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::WhileOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { WhileOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_depth_to_space_options(&self) -> Option<DepthToSpaceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DepthToSpaceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DepthToSpaceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_non_max_suppression_v4_options(&self) -> Option<NonMaxSuppressionV4Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NonMaxSuppressionV4Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NonMaxSuppressionV4Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_non_max_suppression_v5_options(&self) -> Option<NonMaxSuppressionV5Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NonMaxSuppressionV5Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NonMaxSuppressionV5Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_scatter_nd_options(&self) -> Option<ScatterNdOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ScatterNdOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ScatterNdOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_select_v2_options(&self) -> Option<SelectV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SelectV2Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SelectV2Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_densify_options(&self) -> Option<DensifyOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DensifyOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DensifyOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_segment_sum_options(&self) -> Option<SegmentSumOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SegmentSumOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SegmentSumOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_batch_mat_mul_options(&self) -> Option<BatchMatMulOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BatchMatMulOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BatchMatMulOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_cumsum_options(&self) -> Option<CumsumOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CumsumOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CumsumOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_call_once_options(&self) -> Option<CallOnceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CallOnceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CallOnceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_broadcast_to_options(&self) -> Option<BroadcastToOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BroadcastToOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BroadcastToOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_rfft_2d_options(&self) -> Option<Rfft2dOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::Rfft2dOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Rfft2dOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_conv_3_doptions(&self) -> Option<Conv3DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::Conv3DOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Conv3DOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_hashtable_options(&self) -> Option<HashtableOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::HashtableOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashtableOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_hashtable_find_options(&self) -> Option<HashtableFindOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::HashtableFindOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashtableFindOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_hashtable_import_options(&self) -> Option<HashtableImportOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::HashtableImportOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashtableImportOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_hashtable_size_options(&self) -> Option<HashtableSizeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::HashtableSizeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashtableSizeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_var_handle_options(&self) -> Option<VarHandleOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::VarHandleOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { VarHandleOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_read_variable_options(&self) -> Option<ReadVariableOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReadVariableOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReadVariableOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_assign_variable_options(&self) -> Option<AssignVariableOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AssignVariableOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AssignVariableOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_random_options(&self) -> Option<RandomOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RandomOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RandomOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bucketize_options(&self) -> Option<BucketizeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BucketizeOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BucketizeOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_gelu_options(&self) -> Option<GeluOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GeluOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GeluOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_dynamic_update_slice_options(&self) -> Option<DynamicUpdateSliceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DynamicUpdateSliceOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DynamicUpdateSliceOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unsorted_segment_prod_options(&self) -> Option<UnsortedSegmentProdOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentProdOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnsortedSegmentProdOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unsorted_segment_max_options(&self) -> Option<UnsortedSegmentMaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentMaxOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnsortedSegmentMaxOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unsorted_segment_min_options(&self) -> Option<UnsortedSegmentMinOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentMinOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnsortedSegmentMinOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unsorted_segment_sum_options(&self) -> Option<UnsortedSegmentSumOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentSumOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnsortedSegmentSumOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_atan_2_options(&self) -> Option<ATan2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ATan2Options {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ATan2Options::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sign_options(&self) -> Option<SignOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SignOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SignOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bitcast_options(&self) -> Option<BitcastOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BitcastOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BitcastOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bitwise_xor_options(&self) -> Option<BitwiseXorOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BitwiseXorOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BitwiseXorOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_right_shift_options(&self) -> Option<RightShiftOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RightShiftOptions {
      self.builtin_options().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RightShiftOptions::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Operator<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("opcode_index", Self::VT_OPCODE_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_union::<BuiltinOptions, _>("builtin_options_type", Self::VT_BUILTIN_OPTIONS_TYPE, "builtin_options", Self::VT_BUILTIN_OPTIONS, false, |key, v, pos| {
        match key {
          BuiltinOptions::Conv2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Conv2DOptions>>("BuiltinOptions::Conv2DOptions", pos),
          BuiltinOptions::DepthwiseConv2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthwiseConv2DOptions>>("BuiltinOptions::DepthwiseConv2DOptions", pos),
          BuiltinOptions::ConcatEmbeddingsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatEmbeddingsOptions>>("BuiltinOptions::ConcatEmbeddingsOptions", pos),
          BuiltinOptions::LSHProjectionOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSHProjectionOptions>>("BuiltinOptions::LSHProjectionOptions", pos),
          BuiltinOptions::Pool2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Pool2DOptions>>("BuiltinOptions::Pool2DOptions", pos),
          BuiltinOptions::SVDFOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SVDFOptions>>("BuiltinOptions::SVDFOptions", pos),
          BuiltinOptions::RNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RNNOptions>>("BuiltinOptions::RNNOptions", pos),
          BuiltinOptions::FullyConnectedOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FullyConnectedOptions>>("BuiltinOptions::FullyConnectedOptions", pos),
          BuiltinOptions::SoftmaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SoftmaxOptions>>("BuiltinOptions::SoftmaxOptions", pos),
          BuiltinOptions::ConcatenationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatenationOptions>>("BuiltinOptions::ConcatenationOptions", pos),
          BuiltinOptions::AddOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddOptions>>("BuiltinOptions::AddOptions", pos),
          BuiltinOptions::L2NormOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<L2NormOptions>>("BuiltinOptions::L2NormOptions", pos),
          BuiltinOptions::LocalResponseNormalizationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LocalResponseNormalizationOptions>>("BuiltinOptions::LocalResponseNormalizationOptions", pos),
          BuiltinOptions::LSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSTMOptions>>("BuiltinOptions::LSTMOptions", pos),
          BuiltinOptions::ResizeBilinearOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeBilinearOptions>>("BuiltinOptions::ResizeBilinearOptions", pos),
          BuiltinOptions::CallOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallOptions>>("BuiltinOptions::CallOptions", pos),
          BuiltinOptions::ReshapeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReshapeOptions>>("BuiltinOptions::ReshapeOptions", pos),
          BuiltinOptions::SkipGramOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SkipGramOptions>>("BuiltinOptions::SkipGramOptions", pos),
          BuiltinOptions::SpaceToDepthOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpaceToDepthOptions>>("BuiltinOptions::SpaceToDepthOptions", pos),
          BuiltinOptions::EmbeddingLookupSparseOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EmbeddingLookupSparseOptions>>("BuiltinOptions::EmbeddingLookupSparseOptions", pos),
          BuiltinOptions::MulOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MulOptions>>("BuiltinOptions::MulOptions", pos),
          BuiltinOptions::PadOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadOptions>>("BuiltinOptions::PadOptions", pos),
          BuiltinOptions::GatherOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherOptions>>("BuiltinOptions::GatherOptions", pos),
          BuiltinOptions::BatchToSpaceNDOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchToSpaceNDOptions>>("BuiltinOptions::BatchToSpaceNDOptions", pos),
          BuiltinOptions::SpaceToBatchNDOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpaceToBatchNDOptions>>("BuiltinOptions::SpaceToBatchNDOptions", pos),
          BuiltinOptions::TransposeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeOptions>>("BuiltinOptions::TransposeOptions", pos),
          BuiltinOptions::ReducerOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReducerOptions>>("BuiltinOptions::ReducerOptions", pos),
          BuiltinOptions::SubOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubOptions>>("BuiltinOptions::SubOptions", pos),
          BuiltinOptions::DivOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DivOptions>>("BuiltinOptions::DivOptions", pos),
          BuiltinOptions::SqueezeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SqueezeOptions>>("BuiltinOptions::SqueezeOptions", pos),
          BuiltinOptions::SequenceRNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceRNNOptions>>("BuiltinOptions::SequenceRNNOptions", pos),
          BuiltinOptions::StridedSliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StridedSliceOptions>>("BuiltinOptions::StridedSliceOptions", pos),
          BuiltinOptions::ExpOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpOptions>>("BuiltinOptions::ExpOptions", pos),
          BuiltinOptions::TopKV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TopKV2Options>>("BuiltinOptions::TopKV2Options", pos),
          BuiltinOptions::SplitOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitOptions>>("BuiltinOptions::SplitOptions", pos),
          BuiltinOptions::LogSoftmaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogSoftmaxOptions>>("BuiltinOptions::LogSoftmaxOptions", pos),
          BuiltinOptions::CastOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastOptions>>("BuiltinOptions::CastOptions", pos),
          BuiltinOptions::DequantizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DequantizeOptions>>("BuiltinOptions::DequantizeOptions", pos),
          BuiltinOptions::MaximumMinimumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MaximumMinimumOptions>>("BuiltinOptions::MaximumMinimumOptions", pos),
          BuiltinOptions::ArgMaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMaxOptions>>("BuiltinOptions::ArgMaxOptions", pos),
          BuiltinOptions::LessOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LessOptions>>("BuiltinOptions::LessOptions", pos),
          BuiltinOptions::NegOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NegOptions>>("BuiltinOptions::NegOptions", pos),
          BuiltinOptions::PadV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadV2Options>>("BuiltinOptions::PadV2Options", pos),
          BuiltinOptions::GreaterOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GreaterOptions>>("BuiltinOptions::GreaterOptions", pos),
          BuiltinOptions::GreaterEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GreaterEqualOptions>>("BuiltinOptions::GreaterEqualOptions", pos),
          BuiltinOptions::LessEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LessEqualOptions>>("BuiltinOptions::LessEqualOptions", pos),
          BuiltinOptions::SelectOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SelectOptions>>("BuiltinOptions::SelectOptions", pos),
          BuiltinOptions::SliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SliceOptions>>("BuiltinOptions::SliceOptions", pos),
          BuiltinOptions::TransposeConvOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeConvOptions>>("BuiltinOptions::TransposeConvOptions", pos),
          BuiltinOptions::SparseToDenseOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseToDenseOptions>>("BuiltinOptions::SparseToDenseOptions", pos),
          BuiltinOptions::TileOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TileOptions>>("BuiltinOptions::TileOptions", pos),
          BuiltinOptions::ExpandDimsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpandDimsOptions>>("BuiltinOptions::ExpandDimsOptions", pos),
          BuiltinOptions::EqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EqualOptions>>("BuiltinOptions::EqualOptions", pos),
          BuiltinOptions::NotEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NotEqualOptions>>("BuiltinOptions::NotEqualOptions", pos),
          BuiltinOptions::ShapeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ShapeOptions>>("BuiltinOptions::ShapeOptions", pos),
          BuiltinOptions::PowOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PowOptions>>("BuiltinOptions::PowOptions", pos),
          BuiltinOptions::ArgMinOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMinOptions>>("BuiltinOptions::ArgMinOptions", pos),
          BuiltinOptions::FakeQuantOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FakeQuantOptions>>("BuiltinOptions::FakeQuantOptions", pos),
          BuiltinOptions::PackOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PackOptions>>("BuiltinOptions::PackOptions", pos),
          BuiltinOptions::LogicalOrOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalOrOptions>>("BuiltinOptions::LogicalOrOptions", pos),
          BuiltinOptions::OneHotOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OneHotOptions>>("BuiltinOptions::OneHotOptions", pos),
          BuiltinOptions::LogicalAndOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalAndOptions>>("BuiltinOptions::LogicalAndOptions", pos),
          BuiltinOptions::LogicalNotOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalNotOptions>>("BuiltinOptions::LogicalNotOptions", pos),
          BuiltinOptions::UnpackOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnpackOptions>>("BuiltinOptions::UnpackOptions", pos),
          BuiltinOptions::FloorDivOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloorDivOptions>>("BuiltinOptions::FloorDivOptions", pos),
          BuiltinOptions::SquareOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SquareOptions>>("BuiltinOptions::SquareOptions", pos),
          BuiltinOptions::ZerosLikeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ZerosLikeOptions>>("BuiltinOptions::ZerosLikeOptions", pos),
          BuiltinOptions::FillOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FillOptions>>("BuiltinOptions::FillOptions", pos),
          BuiltinOptions::BidirectionalSequenceLSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BidirectionalSequenceLSTMOptions>>("BuiltinOptions::BidirectionalSequenceLSTMOptions", pos),
          BuiltinOptions::BidirectionalSequenceRNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BidirectionalSequenceRNNOptions>>("BuiltinOptions::BidirectionalSequenceRNNOptions", pos),
          BuiltinOptions::UnidirectionalSequenceLSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnidirectionalSequenceLSTMOptions>>("BuiltinOptions::UnidirectionalSequenceLSTMOptions", pos),
          BuiltinOptions::FloorModOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloorModOptions>>("BuiltinOptions::FloorModOptions", pos),
          BuiltinOptions::RangeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RangeOptions>>("BuiltinOptions::RangeOptions", pos),
          BuiltinOptions::ResizeNearestNeighborOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeNearestNeighborOptions>>("BuiltinOptions::ResizeNearestNeighborOptions", pos),
          BuiltinOptions::LeakyReluOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeakyReluOptions>>("BuiltinOptions::LeakyReluOptions", pos),
          BuiltinOptions::SquaredDifferenceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SquaredDifferenceOptions>>("BuiltinOptions::SquaredDifferenceOptions", pos),
          BuiltinOptions::MirrorPadOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MirrorPadOptions>>("BuiltinOptions::MirrorPadOptions", pos),
          BuiltinOptions::AbsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AbsOptions>>("BuiltinOptions::AbsOptions", pos),
          BuiltinOptions::SplitVOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitVOptions>>("BuiltinOptions::SplitVOptions", pos),
          BuiltinOptions::UniqueOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UniqueOptions>>("BuiltinOptions::UniqueOptions", pos),
          BuiltinOptions::ReverseV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReverseV2Options>>("BuiltinOptions::ReverseV2Options", pos),
          BuiltinOptions::AddNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddNOptions>>("BuiltinOptions::AddNOptions", pos),
          BuiltinOptions::GatherNdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherNdOptions>>("BuiltinOptions::GatherNdOptions", pos),
          BuiltinOptions::CosOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CosOptions>>("BuiltinOptions::CosOptions", pos),
          BuiltinOptions::WhereOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhereOptions>>("BuiltinOptions::WhereOptions", pos),
          BuiltinOptions::RankOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RankOptions>>("BuiltinOptions::RankOptions", pos),
          BuiltinOptions::ReverseSequenceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReverseSequenceOptions>>("BuiltinOptions::ReverseSequenceOptions", pos),
          BuiltinOptions::MatrixDiagOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatrixDiagOptions>>("BuiltinOptions::MatrixDiagOptions", pos),
          BuiltinOptions::QuantizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QuantizeOptions>>("BuiltinOptions::QuantizeOptions", pos),
          BuiltinOptions::MatrixSetDiagOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatrixSetDiagOptions>>("BuiltinOptions::MatrixSetDiagOptions", pos),
          BuiltinOptions::HardSwishOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HardSwishOptions>>("BuiltinOptions::HardSwishOptions", pos),
          BuiltinOptions::IfOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IfOptions>>("BuiltinOptions::IfOptions", pos),
          BuiltinOptions::WhileOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhileOptions>>("BuiltinOptions::WhileOptions", pos),
          BuiltinOptions::DepthToSpaceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthToSpaceOptions>>("BuiltinOptions::DepthToSpaceOptions", pos),
          BuiltinOptions::NonMaxSuppressionV4Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionV4Options>>("BuiltinOptions::NonMaxSuppressionV4Options", pos),
          BuiltinOptions::NonMaxSuppressionV5Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionV5Options>>("BuiltinOptions::NonMaxSuppressionV5Options", pos),
          BuiltinOptions::ScatterNdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScatterNdOptions>>("BuiltinOptions::ScatterNdOptions", pos),
          BuiltinOptions::SelectV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SelectV2Options>>("BuiltinOptions::SelectV2Options", pos),
          BuiltinOptions::DensifyOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DensifyOptions>>("BuiltinOptions::DensifyOptions", pos),
          BuiltinOptions::SegmentSumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SegmentSumOptions>>("BuiltinOptions::SegmentSumOptions", pos),
          BuiltinOptions::BatchMatMulOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchMatMulOptions>>("BuiltinOptions::BatchMatMulOptions", pos),
          BuiltinOptions::CumsumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CumsumOptions>>("BuiltinOptions::CumsumOptions", pos),
          BuiltinOptions::CallOnceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallOnceOptions>>("BuiltinOptions::CallOnceOptions", pos),
          BuiltinOptions::BroadcastToOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BroadcastToOptions>>("BuiltinOptions::BroadcastToOptions", pos),
          BuiltinOptions::Rfft2dOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Rfft2dOptions>>("BuiltinOptions::Rfft2dOptions", pos),
          BuiltinOptions::Conv3DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Conv3DOptions>>("BuiltinOptions::Conv3DOptions", pos),
          BuiltinOptions::HashtableOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableOptions>>("BuiltinOptions::HashtableOptions", pos),
          BuiltinOptions::HashtableFindOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableFindOptions>>("BuiltinOptions::HashtableFindOptions", pos),
          BuiltinOptions::HashtableImportOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableImportOptions>>("BuiltinOptions::HashtableImportOptions", pos),
          BuiltinOptions::HashtableSizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableSizeOptions>>("BuiltinOptions::HashtableSizeOptions", pos),
          BuiltinOptions::VarHandleOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VarHandleOptions>>("BuiltinOptions::VarHandleOptions", pos),
          BuiltinOptions::ReadVariableOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadVariableOptions>>("BuiltinOptions::ReadVariableOptions", pos),
          BuiltinOptions::AssignVariableOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AssignVariableOptions>>("BuiltinOptions::AssignVariableOptions", pos),
          BuiltinOptions::RandomOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomOptions>>("BuiltinOptions::RandomOptions", pos),
          BuiltinOptions::BucketizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BucketizeOptions>>("BuiltinOptions::BucketizeOptions", pos),
          BuiltinOptions::GeluOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GeluOptions>>("BuiltinOptions::GeluOptions", pos),
          BuiltinOptions::DynamicUpdateSliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DynamicUpdateSliceOptions>>("BuiltinOptions::DynamicUpdateSliceOptions", pos),
          BuiltinOptions::UnsortedSegmentProdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentProdOptions>>("BuiltinOptions::UnsortedSegmentProdOptions", pos),
          BuiltinOptions::UnsortedSegmentMaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentMaxOptions>>("BuiltinOptions::UnsortedSegmentMaxOptions", pos),
          BuiltinOptions::UnsortedSegmentMinOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentMinOptions>>("BuiltinOptions::UnsortedSegmentMinOptions", pos),
          BuiltinOptions::UnsortedSegmentSumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentSumOptions>>("BuiltinOptions::UnsortedSegmentSumOptions", pos),
          BuiltinOptions::ATan2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ATan2Options>>("BuiltinOptions::ATan2Options", pos),
          BuiltinOptions::SignOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SignOptions>>("BuiltinOptions::SignOptions", pos),
          BuiltinOptions::BitcastOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BitcastOptions>>("BuiltinOptions::BitcastOptions", pos),
          BuiltinOptions::BitwiseXorOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BitwiseXorOptions>>("BuiltinOptions::BitwiseXorOptions", pos),
          BuiltinOptions::RightShiftOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RightShiftOptions>>("BuiltinOptions::RightShiftOptions", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("custom_options", Self::VT_CUSTOM_OPTIONS, false)?
     .visit_field::<CustomOptionsFormat>("custom_options_format", Self::VT_CUSTOM_OPTIONS_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("mutating_variable_inputs", Self::VT_MUTATING_VARIABLE_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("intermediates", Self::VT_INTERMEDIATES, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorArgs<'a> {
    pub opcode_index: u32,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub builtin_options_type: BuiltinOptions,
    pub builtin_options: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub custom_options: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub custom_options_format: CustomOptionsFormat,
    pub mutating_variable_inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub intermediates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for OperatorArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorArgs {
      opcode_index: 0,
      inputs: None,
      outputs: None,
      builtin_options_type: BuiltinOptions::NONE,
      builtin_options: None,
      custom_options: None,
      custom_options_format: CustomOptionsFormat::FLEXBUFFERS,
      mutating_variable_inputs: None,
      intermediates: None,
    }
  }
}

pub struct OperatorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorBuilder<'a, 'b> {
  #[inline]
  pub fn add_opcode_index(&mut self, opcode_index: u32) {
    self.fbb_.push_slot::<u32>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_builtin_options_type(&mut self, builtin_options_type: BuiltinOptions) {
    self.fbb_.push_slot::<BuiltinOptions>(Operator::VT_BUILTIN_OPTIONS_TYPE, builtin_options_type, BuiltinOptions::NONE);
  }
  #[inline]
  pub fn add_builtin_options(&mut self, builtin_options: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  #[inline]
  pub fn add_custom_options(&mut self, custom_options: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  #[inline]
  pub fn add_custom_options_format(&mut self, custom_options_format: CustomOptionsFormat) {
    self.fbb_.push_slot::<CustomOptionsFormat>(Operator::VT_CUSTOM_OPTIONS_FORMAT, custom_options_format, CustomOptionsFormat::FLEXBUFFERS);
  }
  #[inline]
  pub fn add_mutating_variable_inputs(&mut self, mutating_variable_inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  #[inline]
  pub fn add_intermediates(&mut self, intermediates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_INTERMEDIATES, intermediates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperatorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operator<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Operator<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Operator");
      ds.field("opcode_index", &self.opcode_index());
      ds.field("inputs", &self.inputs());
      ds.field("outputs", &self.outputs());
      ds.field("builtin_options_type", &self.builtin_options_type());
      match self.builtin_options_type() {
        BuiltinOptions::Conv2DOptions => {
          if let Some(x) = self.builtin_options_as_conv_2_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DepthwiseConv2DOptions => {
          if let Some(x) = self.builtin_options_as_depthwise_conv_2_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ConcatEmbeddingsOptions => {
          if let Some(x) = self.builtin_options_as_concat_embeddings_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LSHProjectionOptions => {
          if let Some(x) = self.builtin_options_as_lshprojection_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::Pool2DOptions => {
          if let Some(x) = self.builtin_options_as_pool_2_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SVDFOptions => {
          if let Some(x) = self.builtin_options_as_svdfoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RNNOptions => {
          if let Some(x) = self.builtin_options_as_rnnoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FullyConnectedOptions => {
          if let Some(x) = self.builtin_options_as_fully_connected_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SoftmaxOptions => {
          if let Some(x) = self.builtin_options_as_softmax_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ConcatenationOptions => {
          if let Some(x) = self.builtin_options_as_concatenation_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AddOptions => {
          if let Some(x) = self.builtin_options_as_add_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::L2NormOptions => {
          if let Some(x) = self.builtin_options_as_l2_norm_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LocalResponseNormalizationOptions => {
          if let Some(x) = self.builtin_options_as_local_response_normalization_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LSTMOptions => {
          if let Some(x) = self.builtin_options_as_lstmoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ResizeBilinearOptions => {
          if let Some(x) = self.builtin_options_as_resize_bilinear_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CallOptions => {
          if let Some(x) = self.builtin_options_as_call_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReshapeOptions => {
          if let Some(x) = self.builtin_options_as_reshape_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SkipGramOptions => {
          if let Some(x) = self.builtin_options_as_skip_gram_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SpaceToDepthOptions => {
          if let Some(x) = self.builtin_options_as_space_to_depth_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::EmbeddingLookupSparseOptions => {
          if let Some(x) = self.builtin_options_as_embedding_lookup_sparse_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MulOptions => {
          if let Some(x) = self.builtin_options_as_mul_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PadOptions => {
          if let Some(x) = self.builtin_options_as_pad_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GatherOptions => {
          if let Some(x) = self.builtin_options_as_gather_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BatchToSpaceNDOptions => {
          if let Some(x) = self.builtin_options_as_batch_to_space_ndoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SpaceToBatchNDOptions => {
          if let Some(x) = self.builtin_options_as_space_to_batch_ndoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TransposeOptions => {
          if let Some(x) = self.builtin_options_as_transpose_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReducerOptions => {
          if let Some(x) = self.builtin_options_as_reducer_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SubOptions => {
          if let Some(x) = self.builtin_options_as_sub_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DivOptions => {
          if let Some(x) = self.builtin_options_as_div_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SqueezeOptions => {
          if let Some(x) = self.builtin_options_as_squeeze_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SequenceRNNOptions => {
          if let Some(x) = self.builtin_options_as_sequence_rnnoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::StridedSliceOptions => {
          if let Some(x) = self.builtin_options_as_strided_slice_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ExpOptions => {
          if let Some(x) = self.builtin_options_as_exp_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TopKV2Options => {
          if let Some(x) = self.builtin_options_as_top_kv2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SplitOptions => {
          if let Some(x) = self.builtin_options_as_split_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogSoftmaxOptions => {
          if let Some(x) = self.builtin_options_as_log_softmax_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CastOptions => {
          if let Some(x) = self.builtin_options_as_cast_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DequantizeOptions => {
          if let Some(x) = self.builtin_options_as_dequantize_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MaximumMinimumOptions => {
          if let Some(x) = self.builtin_options_as_maximum_minimum_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ArgMaxOptions => {
          if let Some(x) = self.builtin_options_as_arg_max_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LessOptions => {
          if let Some(x) = self.builtin_options_as_less_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NegOptions => {
          if let Some(x) = self.builtin_options_as_neg_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PadV2Options => {
          if let Some(x) = self.builtin_options_as_pad_v2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GreaterOptions => {
          if let Some(x) = self.builtin_options_as_greater_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GreaterEqualOptions => {
          if let Some(x) = self.builtin_options_as_greater_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LessEqualOptions => {
          if let Some(x) = self.builtin_options_as_less_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SelectOptions => {
          if let Some(x) = self.builtin_options_as_select_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SliceOptions => {
          if let Some(x) = self.builtin_options_as_slice_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TransposeConvOptions => {
          if let Some(x) = self.builtin_options_as_transpose_conv_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SparseToDenseOptions => {
          if let Some(x) = self.builtin_options_as_sparse_to_dense_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TileOptions => {
          if let Some(x) = self.builtin_options_as_tile_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ExpandDimsOptions => {
          if let Some(x) = self.builtin_options_as_expand_dims_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::EqualOptions => {
          if let Some(x) = self.builtin_options_as_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NotEqualOptions => {
          if let Some(x) = self.builtin_options_as_not_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ShapeOptions => {
          if let Some(x) = self.builtin_options_as_shape_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PowOptions => {
          if let Some(x) = self.builtin_options_as_pow_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ArgMinOptions => {
          if let Some(x) = self.builtin_options_as_arg_min_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FakeQuantOptions => {
          if let Some(x) = self.builtin_options_as_fake_quant_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PackOptions => {
          if let Some(x) = self.builtin_options_as_pack_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogicalOrOptions => {
          if let Some(x) = self.builtin_options_as_logical_or_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::OneHotOptions => {
          if let Some(x) = self.builtin_options_as_one_hot_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogicalAndOptions => {
          if let Some(x) = self.builtin_options_as_logical_and_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogicalNotOptions => {
          if let Some(x) = self.builtin_options_as_logical_not_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnpackOptions => {
          if let Some(x) = self.builtin_options_as_unpack_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FloorDivOptions => {
          if let Some(x) = self.builtin_options_as_floor_div_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SquareOptions => {
          if let Some(x) = self.builtin_options_as_square_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ZerosLikeOptions => {
          if let Some(x) = self.builtin_options_as_zeros_like_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FillOptions => {
          if let Some(x) = self.builtin_options_as_fill_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BidirectionalSequenceLSTMOptions => {
          if let Some(x) = self.builtin_options_as_bidirectional_sequence_lstmoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BidirectionalSequenceRNNOptions => {
          if let Some(x) = self.builtin_options_as_bidirectional_sequence_rnnoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnidirectionalSequenceLSTMOptions => {
          if let Some(x) = self.builtin_options_as_unidirectional_sequence_lstmoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FloorModOptions => {
          if let Some(x) = self.builtin_options_as_floor_mod_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RangeOptions => {
          if let Some(x) = self.builtin_options_as_range_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ResizeNearestNeighborOptions => {
          if let Some(x) = self.builtin_options_as_resize_nearest_neighbor_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LeakyReluOptions => {
          if let Some(x) = self.builtin_options_as_leaky_relu_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SquaredDifferenceOptions => {
          if let Some(x) = self.builtin_options_as_squared_difference_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MirrorPadOptions => {
          if let Some(x) = self.builtin_options_as_mirror_pad_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AbsOptions => {
          if let Some(x) = self.builtin_options_as_abs_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SplitVOptions => {
          if let Some(x) = self.builtin_options_as_split_voptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UniqueOptions => {
          if let Some(x) = self.builtin_options_as_unique_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReverseV2Options => {
          if let Some(x) = self.builtin_options_as_reverse_v2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AddNOptions => {
          if let Some(x) = self.builtin_options_as_add_noptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GatherNdOptions => {
          if let Some(x) = self.builtin_options_as_gather_nd_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CosOptions => {
          if let Some(x) = self.builtin_options_as_cos_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::WhereOptions => {
          if let Some(x) = self.builtin_options_as_where_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RankOptions => {
          if let Some(x) = self.builtin_options_as_rank_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReverseSequenceOptions => {
          if let Some(x) = self.builtin_options_as_reverse_sequence_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MatrixDiagOptions => {
          if let Some(x) = self.builtin_options_as_matrix_diag_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::QuantizeOptions => {
          if let Some(x) = self.builtin_options_as_quantize_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MatrixSetDiagOptions => {
          if let Some(x) = self.builtin_options_as_matrix_set_diag_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::HardSwishOptions => {
          if let Some(x) = self.builtin_options_as_hard_swish_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::IfOptions => {
          if let Some(x) = self.builtin_options_as_if_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::WhileOptions => {
          if let Some(x) = self.builtin_options_as_while_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DepthToSpaceOptions => {
          if let Some(x) = self.builtin_options_as_depth_to_space_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NonMaxSuppressionV4Options => {
          if let Some(x) = self.builtin_options_as_non_max_suppression_v4_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NonMaxSuppressionV5Options => {
          if let Some(x) = self.builtin_options_as_non_max_suppression_v5_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ScatterNdOptions => {
          if let Some(x) = self.builtin_options_as_scatter_nd_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SelectV2Options => {
          if let Some(x) = self.builtin_options_as_select_v2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DensifyOptions => {
          if let Some(x) = self.builtin_options_as_densify_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SegmentSumOptions => {
          if let Some(x) = self.builtin_options_as_segment_sum_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BatchMatMulOptions => {
          if let Some(x) = self.builtin_options_as_batch_mat_mul_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CumsumOptions => {
          if let Some(x) = self.builtin_options_as_cumsum_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CallOnceOptions => {
          if let Some(x) = self.builtin_options_as_call_once_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BroadcastToOptions => {
          if let Some(x) = self.builtin_options_as_broadcast_to_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::Rfft2dOptions => {
          if let Some(x) = self.builtin_options_as_rfft_2d_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::Conv3DOptions => {
          if let Some(x) = self.builtin_options_as_conv_3_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::HashtableOptions => {
          if let Some(x) = self.builtin_options_as_hashtable_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::HashtableFindOptions => {
          if let Some(x) = self.builtin_options_as_hashtable_find_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::HashtableImportOptions => {
          if let Some(x) = self.builtin_options_as_hashtable_import_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::HashtableSizeOptions => {
          if let Some(x) = self.builtin_options_as_hashtable_size_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::VarHandleOptions => {
          if let Some(x) = self.builtin_options_as_var_handle_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReadVariableOptions => {
          if let Some(x) = self.builtin_options_as_read_variable_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AssignVariableOptions => {
          if let Some(x) = self.builtin_options_as_assign_variable_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RandomOptions => {
          if let Some(x) = self.builtin_options_as_random_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BucketizeOptions => {
          if let Some(x) = self.builtin_options_as_bucketize_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GeluOptions => {
          if let Some(x) = self.builtin_options_as_gelu_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DynamicUpdateSliceOptions => {
          if let Some(x) = self.builtin_options_as_dynamic_update_slice_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnsortedSegmentProdOptions => {
          if let Some(x) = self.builtin_options_as_unsorted_segment_prod_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnsortedSegmentMaxOptions => {
          if let Some(x) = self.builtin_options_as_unsorted_segment_max_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnsortedSegmentMinOptions => {
          if let Some(x) = self.builtin_options_as_unsorted_segment_min_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnsortedSegmentSumOptions => {
          if let Some(x) = self.builtin_options_as_unsorted_segment_sum_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ATan2Options => {
          if let Some(x) = self.builtin_options_as_atan_2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SignOptions => {
          if let Some(x) = self.builtin_options_as_sign_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BitcastOptions => {
          if let Some(x) = self.builtin_options_as_bitcast_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BitwiseXorOptions => {
          if let Some(x) = self.builtin_options_as_bitwise_xor_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RightShiftOptions => {
          if let Some(x) = self.builtin_options_as_right_shift_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("builtin_options", &x)
        },
      };
      ds.field("custom_options", &self.custom_options());
      ds.field("custom_options_format", &self.custom_options_format());
      ds.field("mutating_variable_inputs", &self.mutating_variable_inputs());
      ds.field("intermediates", &self.intermediates());
      ds.finish()
  }
}
pub enum SubGraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubGraph<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubGraph<'a> {
  type Inner = SubGraph<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SubGraph<'a> {
  pub const VT_TENSORS: flatbuffers::VOffsetT = 4;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
  pub const VT_OPERATORS: flatbuffers::VOffsetT = 10;
  pub const VT_NAME: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubGraph { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubGraphArgs<'args>
  ) -> flatbuffers::WIPOffset<SubGraph<'bldr>> {
    let mut builder = SubGraphBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.operators { builder.add_operators(x); }
    if let Some(x) = args.outputs { builder.add_outputs(x); }
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.tensors { builder.add_tensors(x); }
    builder.finish()
  }


  #[inline]
  pub fn tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor>>>>(SubGraph::VT_TENSORS, None)}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SubGraph::VT_INPUTS, None)}
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SubGraph::VT_OUTPUTS, None)}
  }
  #[inline]
  pub fn operators(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator>>>>(SubGraph::VT_OPERATORS, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubGraph::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for SubGraph<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tensor>>>>("tensors", Self::VT_TENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Operator>>>>("operators", Self::VT_OPERATORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct SubGraphArgs<'a> {
    pub tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub operators: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator<'a>>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SubGraphArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubGraphArgs {
      tensors: None,
      inputs: None,
      outputs: None,
      operators: None,
      name: None,
    }
  }
}

pub struct SubGraphBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubGraphBuilder<'a, 'b> {
  #[inline]
  pub fn add_tensors(&mut self, tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Tensor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_TENSORS, tensors);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_operators(&mut self, operators: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Operator<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_OPERATORS, operators);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubGraphBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubGraphBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubGraph<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubGraph<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubGraph");
      ds.field("tensors", &self.tensors());
      ds.field("inputs", &self.inputs());
      ds.field("outputs", &self.outputs());
      ds.field("operators", &self.operators());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum BufferOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Buffer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Buffer<'a> {
  type Inner = Buffer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Buffer<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Buffer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BufferArgs<'args>
  ) -> flatbuffers::WIPOffset<Buffer<'bldr>> {
    let mut builder = BufferBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Buffer::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for Buffer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BufferArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BufferArgs<'a> {
  #[inline]
  fn default() -> Self {
    BufferArgs {
      data: None,
    }
  }
}

pub struct BufferBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BufferBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Buffer::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BufferBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BufferBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Buffer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Buffer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Buffer");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
  type Inner = Metadata<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Metadata<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_BUFFER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Metadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MetadataArgs<'args>
  ) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
    let mut builder = MetadataBuilder::new(_fbb);
    builder.add_buffer(args.buffer);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_NAME, None)}
  }
  #[inline]
  pub fn buffer(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Metadata::VT_BUFFER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Metadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u32>("buffer", Self::VT_BUFFER, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffer: u32,
}
impl<'a> Default for MetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetadataArgs {
      name: None,
      buffer: 0,
    }
  }
}

pub struct MetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_NAME, name);
  }
  #[inline]
  pub fn add_buffer(&mut self, buffer: u32) {
    self.fbb_.push_slot::<u32>(Metadata::VT_BUFFER, buffer, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("name", &self.name());
      ds.field("buffer", &self.buffer());
      ds.finish()
  }
}
pub enum TensorMapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorMap<'a> {
  type Inner = TensorMap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorMap<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TENSOR_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorMap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorMapArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorMap<'bldr>> {
    let mut builder = TensorMapBuilder::new(_fbb);
    builder.add_tensor_index(args.tensor_index);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorMap::VT_NAME, None)}
  }
  #[inline]
  pub fn tensor_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorMap::VT_TENSOR_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TensorMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u32>("tensor_index", Self::VT_TENSOR_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorMapArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tensor_index: u32,
}
impl<'a> Default for TensorMapArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorMapArgs {
      name: None,
      tensor_index: 0,
    }
  }
}

pub struct TensorMapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorMapBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorMap::VT_NAME, name);
  }
  #[inline]
  pub fn add_tensor_index(&mut self, tensor_index: u32) {
    self.fbb_.push_slot::<u32>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorMapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorMap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorMap");
      ds.field("name", &self.name());
      ds.field("tensor_index", &self.tensor_index());
      ds.finish()
  }
}
pub enum SignatureDefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignatureDef<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignatureDef<'a> {
  type Inner = SignatureDef<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignatureDef<'a> {
  pub const VT_INPUTS: flatbuffers::VOffsetT = 4;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 6;
  pub const VT_SIGNATURE_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignatureDef { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SignatureDefArgs<'args>
  ) -> flatbuffers::WIPOffset<SignatureDef<'bldr>> {
    let mut builder = SignatureDefBuilder::new(_fbb);
    builder.add_subgraph_index(args.subgraph_index);
    if let Some(x) = args.signature_key { builder.add_signature_key(x); }
    if let Some(x) = args.outputs { builder.add_outputs(x); }
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    builder.finish()
  }


  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap>>>>(SignatureDef::VT_INPUTS, None)}
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap>>>>(SignatureDef::VT_OUTPUTS, None)}
  }
  #[inline]
  pub fn signature_key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignatureDef::VT_SIGNATURE_KEY, None)}
  }
  #[inline]
  pub fn subgraph_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SignatureDef::VT_SUBGRAPH_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SignatureDef<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorMap>>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorMap>>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("signature_key", Self::VT_SIGNATURE_KEY, false)?
     .visit_field::<u32>("subgraph_index", Self::VT_SUBGRAPH_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct SignatureDefArgs<'a> {
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>>>,
    pub signature_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subgraph_index: u32,
}
impl<'a> Default for SignatureDefArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignatureDefArgs {
      inputs: None,
      outputs: None,
      signature_key: None,
      subgraph_index: 0,
    }
  }
}

pub struct SignatureDefBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SignatureDefBuilder<'a, 'b> {
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorMap<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignatureDef::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorMap<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignatureDef::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_signature_key(&mut self, signature_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignatureDef::VT_SIGNATURE_KEY, signature_key);
  }
  #[inline]
  pub fn add_subgraph_index(&mut self, subgraph_index: u32) {
    self.fbb_.push_slot::<u32>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignatureDefBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SignatureDefBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignatureDef<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignatureDef<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignatureDef");
      ds.field("inputs", &self.inputs());
      ds.field("outputs", &self.outputs());
      ds.field("signature_key", &self.signature_key());
      ds.field("subgraph_index", &self.subgraph_index());
      ds.finish()
  }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
  type Inner = Model<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Model<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATOR_CODES: flatbuffers::VOffsetT = 6;
  pub const VT_SUBGRAPHS: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_BUFFERS: flatbuffers::VOffsetT = 12;
  pub const VT_METADATA_BUFFER: flatbuffers::VOffsetT = 14;
  pub const VT_METADATA: flatbuffers::VOffsetT = 16;
  pub const VT_SIGNATURE_DEFS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Model { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ModelArgs<'args>
  ) -> flatbuffers::WIPOffset<Model<'bldr>> {
    let mut builder = ModelBuilder::new(_fbb);
    if let Some(x) = args.signature_defs { builder.add_signature_defs(x); }
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.metadata_buffer { builder.add_metadata_buffer(x); }
    if let Some(x) = args.buffers { builder.add_buffers(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.subgraphs { builder.add_subgraphs(x); }
    if let Some(x) = args.operator_codes { builder.add_operator_codes(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Model::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn operator_codes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode>>>>(Model::VT_OPERATOR_CODES, None)}
  }
  #[inline]
  pub fn subgraphs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph>>>>(Model::VT_SUBGRAPHS, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn buffers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer>>>>(Model::VT_BUFFERS, None)}
  }
  #[inline]
  pub fn metadata_buffer(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Model::VT_METADATA_BUFFER, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata>>>>(Model::VT_METADATA, None)}
  }
  #[inline]
  pub fn signature_defs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SignatureDef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SignatureDef>>>>(Model::VT_SIGNATURE_DEFS, None)}
  }
}

impl flatbuffers::Verifiable for Model<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorCode>>>>("operator_codes", Self::VT_OPERATOR_CODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SubGraph>>>>("subgraphs", Self::VT_SUBGRAPHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Buffer>>>>("buffers", Self::VT_BUFFERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("metadata_buffer", Self::VT_METADATA_BUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Metadata>>>>("metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SignatureDef>>>>("signature_defs", Self::VT_SIGNATURE_DEFS, false)?
     .finish();
    Ok(())
  }
}
pub struct ModelArgs<'a> {
    pub version: u32,
    pub operator_codes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode<'a>>>>>,
    pub subgraphs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph<'a>>>>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>>>,
    pub metadata_buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata<'a>>>>>,
    pub signature_defs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SignatureDef<'a>>>>>,
}
impl<'a> Default for ModelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ModelArgs {
      version: 0,
      operator_codes: None,
      subgraphs: None,
      description: None,
      buffers: None,
      metadata_buffer: None,
      metadata: None,
      signature_defs: None,
    }
  }
}

pub struct ModelBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Model::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_operator_codes(&mut self, operator_codes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OperatorCode<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_OPERATOR_CODES, operator_codes);
  }
  #[inline]
  pub fn add_subgraphs(&mut self, subgraphs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SubGraph<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_SUBGRAPHS, subgraphs);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_buffers(&mut self, buffers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Buffer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_BUFFERS, buffers);
  }
  #[inline]
  pub fn add_metadata_buffer(&mut self, metadata_buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Metadata<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_signature_defs(&mut self, signature_defs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SignatureDef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ModelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Model<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Model");
      ds.field("version", &self.version());
      ds.field("operator_codes", &self.operator_codes());
      ds.field("subgraphs", &self.subgraphs());
      ds.field("description", &self.description());
      ds.field("buffers", &self.buffers());
      ds.field("metadata_buffer", &self.metadata_buffer());
      ds.field("metadata", &self.metadata());
      ds.field("signature_defs", &self.signature_defs());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Model`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Model>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_model_unchecked`.
pub fn size_prefixed_root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Model>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Model` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Model`.
pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
  flatbuffers::root_unchecked::<Model>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
  flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
}
pub const MODEL_IDENTIFIER: &str = "TFL3";

#[inline]
pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
}

#[inline]
pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
}

pub const MODEL_EXTENSION: &str = "tflite";

#[inline]
pub fn finish_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>) {
  fbb.finish(root, Some(MODEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_model_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Model<'a>>) {
  fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
}
}  // pub mod tflite

